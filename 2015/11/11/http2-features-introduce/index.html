
<!DOCTYPE html>
<html lang="en">


<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020"/>
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="HTTP,HTTP2," />
  

  
    <meta name="description" content="HTTP/2特性总结" />
  
  
  
  <link rel="icon" type="image/x-icon" href="/images/footer-logo.png">
  
  <title>HTTP/2特性总结 [ Hexo ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    
    <span class="title" style="text-transform:none">Hexo</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            
              <li class="pure-menu-item"><a href="/" class="pure-menu-link">Home</a></li>
            
          
      
          
            
              <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
            
              <a href="#" id="post" class="pure-menu-link">文章</a>
              <ul class="pure-menu-children">
              
                  
                    <li class="pure-menu-item"><a href="/categories" style="color:#202020;" class="pure-menu-link">Categories</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="/archives" style="color:#202020;" class="pure-menu-link">Archives</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="/tags" style="color:#202020;" class="pure-menu-link">Tags</a></li>
                  
              
              </ul>
            </li>
          
      
          
            
              <li class="pure-menu-item"><a href="/paper" class="pure-menu-link">Papers</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/project" class="pure-menu-link">项目</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/activity" class="pure-menu-link">动态</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/search" class="pure-menu-link">Search</a></li>
            
          
      
  </ul>
   
</nav>

  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        HTTP/2特性总结
      </h1>
      <span>
        
        <time class="time" datetime="2015-11-10T16:00:00.000Z">
        2015-11-11
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP2/" rel="tag">HTTP2</a></li></ul>
      </span>
    </span>
      <span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
      <span class="slash">/</span>
      <span class="read">阅读耗时 26 分钟</span>
    </header>

    <div class="post-content">
      <p>@[toc]</p>
<p>HTTP/2 更简单，高效，强大。它在传输层解决了以前我们HTTP1.x中一直存在的问题。使用它可以优化我们的应用。HTTP/2 的首要目标是通过完全的请求，响应多路复用，头部的压缩头部域来减小头部的体积，添加了请求优先级，服务端推送。为了支持这些特性，他需要大量的协议增加头部字段来支持。例如新的流量控制，差错处理，升级机制。而这些是每个web开发者都应该在他们的应用中用到的。HTTP/2并没有在应用中改变HTTP的语义，而是通过在客户端和服务端传输的数据格式(frame)和传输。它通过在新的二进制帧层控制整个过程以及隐藏复杂性，而这不需要改变原来有的东西就可以实现。</p>
<h1 id="1-HTTP2的设计和目标"><a href="#1-HTTP2的设计和目标" class="headerlink" title="1.HTTP2的设计和目标"></a>1.HTTP2的设计和目标</h1><ul>
<li>HTTP2更简单，高效，强大。解决了HTTP1.x中一直存在的问题。（待扩展）</li>
<li>特点：响应多路复用、头部压缩、请求优先级、服务端推送等。</li>
<li>解决问题：HTTP1.x需要开启多个连接来实现并发和潜在影响。HTTP1.x的头部没有压缩，造成不必要的网络拥塞。HTTP1.x没有应用资源优先级，导致重要TCP连接的糟糕使用。</li>
</ul>
<h1 id="2-二进制帧"><a href="#2-二进制帧" class="headerlink" title="2.二进制帧"></a>2.二进制帧</h1><p>性能提升的核心在于二进制帧。指HTTP消息在客户端和服务端何如封装和传输。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5281821-5e2e23de6cbbc698.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/607/format/webp" alt=""></p>
<p>这一层主要是将原先的应用层HTTP1.1的txt文本传输转换为headers与data等二进制帧。HTTP1.x阶段采用的换行分割文本不同，HTTP2消息分成很小的消息和frame。然后每个消息和frame用二进制编码。客户端和服务端都用二进制编码和解码。HTTP1.x的客户端不能与只有HTTP2的服务端通信。不过这对应用来说高层的API没什么变化，只在底层的消息二进制格式和编解码上的变化来改变性能。</p>
<h1 id="3-流、消息，帧"><a href="#3-流、消息，帧" class="headerlink" title="3.流、消息，帧"></a>3.流、消息，帧</h1><p>下面介绍下二进制帧机制，明白数据如何在客户端和服务端交互。</p>
<blockquote>
<p><strong>流</strong>：已经建立的连接之间双向流动的字节，它能携带一个至多个消息。</p>
<p><strong>消息</strong>：一个完整的帧序列，它映射到逻辑的请求和响应消息。</p>
<p><strong>帧</strong>：在HTTP2通信的最小单位。每个帧包括一个帧头，里面有个很小标志，来区分属于哪个流。</p>
</blockquote>
<ul>
<li>所有的通信都建立在一个TCP连接上，可以传递大量的双向流通的流。</li>
<li>每个流都有独一无二的标志和优先级。</li>
<li>每个消息都是逻辑上的请求和响应消息。由一个活多个帧组成。</li>
<li>来自不同流的帧可以通过帧头的标志关联和组装起来。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5281821-7b0c2aa12ccc6d42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/603/format/webp" alt=""></p>
<h1 id="4-请求和响应的多路复用"><a href="#4-请求和响应的多路复用" class="headerlink" title="4.请求和响应的多路复用"></a>4.请求和响应的多路复用</h1><p>在HTTP1.x中，用户想要多个并行的请求来提供性能，必须得使用多个TCP连接。它能保证在每个连接中在一个时间点只有个响应被发送出去。糟糕的是，它使得队头阻塞和重要TCP连接的低效使用。在HTTP2中，新的二进制帧层解除了这个限制。使得所有的请求和响应可以多路复用。通过允许客户端和服务端把HTTP消息分解成独立的帧，交错的传输，然后在另一端组装。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5281821-ce9d374b7d0adf09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/654/format/webp" alt=""></p>
<p>上图显示了在一次连接中的多个流。客户端传输帧到服务端(stream5)。服务端传输交错的帧序列(stream1，stream3)到客户端。此时，同时存在并行的3个流。能够把HTTP消息分解成交错的帧，并在另一端组装它们是HTTP2中一个非常重要的提高。</p>
<ul>
<li>交错的多个并行的请求，而不需要阻塞。</li>
<li>使用一个连接传递所有的并行的请求和响应。</li>
<li>移除HTTP1.x中没有的必要的解决方法。例如级联文件，域分片。</li>
<li>淘汰没必要的潜在因素来降低页面载入的时间，提升可用网络容积的使用率。</li>
</ul>
<p>新的二进制帧层解决了HTTP1.x中头部阻塞的问题，在并行处理和传输的请求和响应不再需要多个连接，这使得我们的应用更简单，快捷和便宜。</p>
<h1 id="5-流的优先级"><a href="#5-流的优先级" class="headerlink" title="5.流的优先级"></a>5.流的优先级</h1><p>为了能方便的传输顺序，HTTP2提出，使每个流有一个权重和依赖。</p>
<ul>
<li>每个流的权重值1~256之间</li>
<li>每个流可以详细给出对其他流的依赖</li>
</ul>
<p>流权重和依赖的结合使客户端可以构造和通信一个优先级二叉树来表达它更想得到哪种响应。然后服务端可以按权重分配硬件资源（CPU，内存）。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5281821-a424cc207432cde0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/666/format/webp" alt=""></p>
<p>在HTTP2，一个流的依赖可以显式用其他流的标志来表达，如果省略了标志，则说明它的依赖是根流。一般来说，父流应该在它的依赖流之前分配资源。例如D应该是C之前被发送。依赖于同一个父节点的应该按照他们的权重分配资源。例如A节点的权重为12，它的兄弟结点B的结点权重为4。然后按分配资源，A占12/16，B占4/16。如上面所述，流的依赖和权重提供了一种很好的表达式语言来表达资源的优先级。但是，流的依赖和权重只是提供了一种传输偏好，而不是说一定是这样的比例。</p>
<h1 id="6-每个源一个连接"><a href="#6-每个源一个连接" class="headerlink" title="6.每个源一个连接"></a>6.每个源一个连接</h1><p>HTTP2.0的连接是持久的，每个源仅仅需要一个连接。大部分HTTP的传输是短的，并且突然的。然而TCP连接却适合长期存活，批量的数据传输。通过利用相同的HTTP2连接，既能够充分利用TCP连接，也能够减少整体协议的头部。更进一步来说，更少的连接内存的占用以及全连接路径的处理过程。向HTTP2的转移不仅减少了网络潜在因素，更减少了操作代价。</p>
<blockquote>
<p>Tips：减少连接，同时也提高了HTTPS的性能，因为仅需要更少的TLS层的握手。</p>
</blockquote>
<h1 id="7-流量控制"><a href="#7-流量控制" class="headerlink" title="7.流量控制"></a>7.流量控制</h1><p>流量控制是一种机制，用来阻止发送者发送大量的接受者不需要的或者没能力处理的数据。接收者可能会在重负下繁忙，或者只愿意分配固定的资源给特定的流。例如，客户端可能以高的优先级请求大量的视频数据，然后暂停了视频，那么客户端现在想要停止或者减少服务端的传输来避免取和缓存没必要的数据。或者一个代理服务器连接有很快的下流，很慢的上流。同样的也要控制以多大的流速传输数据，从而匹配上流的速度，从而控制资源的使用。</p>
<p>这些需求可能让你想起了TCP流量控制，由于HTTP2的那些流是在一个TCP的连接上。那么TCP连接不够细粒度，也没能够提供应用级的API来控制单个流的传输。为了应对这种情况，HTTP2提供了一系列的简单方法，来允许客户端和服务端实现他们自己的流级别的，连接级别的流量控制。</p>
<ul>
<li>流量控制是有方向的，每个流和连接，每个接收者可以设置它想用窗口的大小。</li>
<li>流量控制是基于信用的。每个接收者通告其初始连接和流量控制窗口（以字节为单位），只要发送者发送数据帧并通过接受者发送的WINDOW_UPDATE帧递增，该窗口就会减少。</li>
<li>流量控制不能禁用。当建立HTTP2连接时，客户端和服务端交换SETTINGS帧，这些帧设置双向流量控制窗口的大小。流量控制窗口的默认设置65535字节，但接收方可以设置更大的最大窗口大小。（2的31次方-1），并通过在接收到任何数据时发送WINDOW_UPDATE帧来维护它。</li>
<li>流量控制是逐跳的，而不是端到端的。也就是，一个中介可以使用它控制资源的使用，从而根据自己的标准和启发式实现资源分配机制。</li>
</ul>
<p>HTTP2没有规定用于实现流量控制的任何特定算法。相反，它提供了简单的构建模块并将实现推迟到客户端和服务器，这可以用它来实现自定义策略来调节资源使用和分配，以及实现新的传输功能。</p>
<p>例如，应用程序层流量控制允许浏览器仅提取特定资源的一部分，通过将流量控制窗口降至零来暂停提取，然后稍后恢复。例如，获取预览或第一预览图像，显示图像并允许进行其他高优先级操作，并在关键资源完成加载后又开始取。</p>
<h1 id="7-服务端推送"><a href="#7-服务端推送" class="headerlink" title="7.服务端推送"></a>7.服务端推送</h1><p>HTTP2的另一个强大的新功能是服务器为单个客户端请求发送多个响应的能力。也就是说，除了对原始请求的响应之外，服务器还可以向客户端推送额外的资源（如下图），而不需要客户端请求每一个资源！</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5281821-d97e0c65b1491baa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/636/format/webp" alt=""></p>
<p>为什么需要在浏览器中使用这种机制？一个典型的Web应用程序由几十个资源组成，所有这些资源都是客户端通过检查服务器提供的文档发现的。因此，为什么不消除额外的延迟并让服务器推送相关资源？服务器已经知道客户端需要哪些资源；这是服务器推送。</p>
<ul>
<li>推送的资源可以由客户端缓存</li>
<li>推送的资源可以在不同的页面上重复使用</li>
<li>推送的资源可以与其他资源一起复用</li>
<li>推送的资源可以由服务器优先</li>
<li>推送的资源可以被客户拒绝</li>
</ul>
<p>每个推送的资源都是一个流，与内联资源不同，它允许客户端对其单独复用，优先化和处理。由浏览器执行的唯一安全限制是推送资源必须遵守同源策略；服务器必须对提供的内容具有权限。</p>
<h1 id="8-头部压缩"><a href="#8-头部压缩" class="headerlink" title="8.头部压缩"></a>8.头部压缩</h1><p>每个HTTP传输都包含一组描述传输资源及其属性的标题。在HTTP/1.x中，此元数据始终以纯文本形式发送，并每次传输的开销都会在任何位置增加500~800字节，如果使用HTTP Cookie，则会增加数千字节。为了减少这种开销并提高性能，HTTP2使用两种简单但强大的技术使用HPACK压缩格式（算法了解<a href="[https://imququ.com/post/header-compression-in-http2.html](https://link.jianshu.com/?t=https%3A%2F%2Fimququ.com%2Fpost%2Fheader-compression-in-http2.html)"></a>）来压缩请求和响应头元数据：</p>
<ul>
<li>它允许通过静态霍夫曼编码对传输的头部字段进行编码，从而减少它们各自的传输大小。</li>
<li>它要求客户端和服务端都维护和更新先前看到的标题字段的索引列表（即，建立共享压缩上下文），然后将其用作参考以高效编码先前传输的值。</li>
</ul>
<p>霍夫曼编码允许单个值在传输时被压缩，并且先前传输值得索引列表允许我们通过传输索引值来编码重复值（下图），索引值可用于有效地查找和重建完整头部键和值。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5281821-38055e8dde4b4436.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/654/format/webp" alt=""></p>
<p>作为进一步优化，HPACK压缩上下文由静态和动态表组成：静态表在规范中定义，并提供给所有连接可能使用的常见HTTP头部字段的列表（例如，有效头名称）。动态表最终是空的，并基于特定连接内的交换值进行更新。因此，通过对以前未见过的值使用静态霍夫曼编码，并将索引替换为已存在与客户端和服务端静态或动态表中的值得索引，可以减少每个请求的大小。</p>
<h1 id="9-二进制帧的简短介绍"><a href="#9-二进制帧的简短介绍" class="headerlink" title="9.二进制帧的简短介绍"></a>9.二进制帧的简短介绍</h1><p>HTTP2改进的核心是新的二进制帧层。与以换行符分割的纯文本HTTP1.x协议相比，二进制框架提供了更紧凑的表示形式，可以更高效地处理并更容易正确实现。</p>
<p>一旦建立了HTTP2连接，客户端和服务端就通过交换帧来进行通信，这些帧用作协议内最小的通信单元。所有帧共享一个共同的9字节头，其中包含帧的长度，类型，标志位字段和31位流标识符。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5281821-d8687e8eed1e6823.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/642/format/webp" alt=""></p>
<ul>
<li>24位长度字段：允许一个帧携带2的24次方数据字节。</li>
<li>8位类型字段：确定帧的格式和语义。</li>
<li>8位标志字段：传递帧类型特定的布尔标志。</li>
<li>31位流标识符：唯一标识HTTP/2流。</li>
</ul>
<blockquote>
<p>从技术上讲，长度字段允许每帧高达字段（<del>16MB）的有效载荷。但是，HTTP2标准将DATA帧的默认最大有效负载大小设置为每帧字节（</del>16KB），并允许客户端和服务器协商较高的值。更大并不总是更好：较小的帧大小能够实现高效的多路复用并将头部阻塞降至最低。</p>
</blockquote>
<h1 id="10-分析二进制帧数据流"><a href="#10-分析二进制帧数据流" class="headerlink" title="10.分析二进制帧数据流"></a>10.分析二进制帧数据流</h1><p>掌握了不同的帧类型的只是后，现在可以重新看下前面在请求和响应复用中遇到的图（下图）并分析HTTP2交换：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5281821-b28c3451bc8fc3fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/682/format/webp" alt=""></p>
<ul>
<li>有三个流，ID设置为1,3和5</li>
<li>所有三个流ID都是奇数；所有这三个都是客户端启动的流。（即发起方是客户端）</li>
<li>在这个交换中没有服务器启动（“推送”）流。（即服务器推送）</li>
<li>服务器正在为流1发送交错数据帧，这些数据帧携带应用程序响应客户端先前的请求。</li>
<li>服务器已经在数据帧之间为流3交错了HEADERS和DATA帧，以便实现流1响应流1响应多路复用。</li>
<li>客户端正在传输数据流5的数据帧，这表明HEADERS帧已在先传输。</li>
</ul>
<p>当然，上述分析基于实际HTTP2交换的简化标识，但它依然说明了新协议的很多优点和特点。</p>

    </div>

  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">Posts</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-HTTP2的设计和目标"><span class="toc-text">1.HTTP2的设计和目标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-二进制帧"><span class="toc-text">2.二进制帧</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-流、消息，帧"><span class="toc-text">3.流、消息，帧</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-请求和响应的多路复用"><span class="toc-text">4.请求和响应的多路复用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-流的优先级"><span class="toc-text">5.流的优先级</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-每个源一个连接"><span class="toc-text">6.每个源一个连接</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-流量控制"><span class="toc-text">7.流量控制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-服务端推送"><span class="toc-text">7.服务端推送</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-头部压缩"><span class="toc-text">8.头部压缩</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-二进制帧的简短介绍"><span class="toc-text">9.二进制帧的简短介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-分析二进制帧数据流"><span class="toc-text">10.分析二进制帧数据流</span></a></li></ol>
  </div>


  </div>
</div>
<div class="copyright">
    <span>本作品采用</span>
    <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>


  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2015/11/05/jetty-source-connection/" rel="next" title="【Jetty源码阅读系列】二、连接管理">
          【Jetty源码阅读系列】二、连接管理
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/2018/10/12/2018-11-4-thinking-huawei-workreview/" rel="prev" title="【职业生涯】2016～2018工作总结">
            【职业生涯】2016～2018工作总结
          </a>
          <span>〉</span>
        
      </div>
    </div>
  

    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <div id="gitalk-container"></div>
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script type="text/javascript">
        var gitalk = new Gitalk({
            clientID: 'xxx',
            clientSecret: 'xxx',
            id: window.location.pathname,
            repo: 'issue repo name',
            owner: 'Github username',
            admin: 'github username'
        })
        gitalk.render('gitalk-container')
    </script>



    </div>

    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" href="https://github.com/fooying" target="_blank">GitHub</a> |
        <a class="bottom-item" href="/links">友情链接</a> |
        <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> |
        <a class="bottom-item" href="https://github.com/fooying/hexo-theme-xoxo-plus" target="_blank">Theme xoxo-plus</a> |
        <a class="bottom-item" href="/atom.xml">RSS</a>
    </div>
</footer>

  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



  
<script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
</script>


</body>
</html>
