
<!DOCTYPE html>
<html lang="en">


<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020"/>
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="" />
  

  
    <meta name="description" content="Hexo," />
  
  
  
  <link rel="icon" type="image/x-icon" href="/images/footer-logo.png">
  
  <title>archives: 2019 [ Hexo ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    
    <span class="title" style="text-transform:none">Hexo</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            
              <li class="pure-menu-item"><a href="/" class="pure-menu-link">Home</a></li>
            
          
      
          
            
              <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover actived">
            
              <a href="#" id="post" class="pure-menu-link">文章</a>
              <ul class="pure-menu-children">
              
                  
                    <li class="pure-menu-item"><a href="/categories" style="color:#202020;" class="pure-menu-link">Categories</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="/archives" class="pure-menu-link">Archives</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="/tags" style="color:#202020;" class="pure-menu-link">Tags</a></li>
                  
              
              </ul>
            </li>
          
      
          
            
              <li class="pure-menu-item"><a href="/paper" class="pure-menu-link">Papers</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/project" class="pure-menu-link">项目</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/activity" class="pure-menu-link">动态</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/search" class="pure-menu-link">Search</a></li>
            
          
      
  </ul>
   
</nav>

  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      

  
  
    
    
    <section class="post page archives">
      <h3 class="archive-year-wrap">
        <a href="/archives/2019" class="archive-year">
          2019
        </a>
      </h3>
      <div class="archives">
  
  <div class="archive" >
  <a class="post-go" href="/2019/12/23/java-concurrency-container-ThreadPool/">
    <div>
      <span class="date">
        12-23
      </span>
      <span class="slash">/</span>
      【并发容器和框架】三、Java线程池的实现原理和使用
    </div>

    <!--<div class="excerpt">-->
      <!--<h1 id="1-Java线程池的实现原理"><a href="#1-Java线程池的实现原理" class="headerlink" title="1. Java线程池的实现原理"></a>1. Java线程池的实现原理</h1><p>线程池是日常开发中使用最多的并发框架（虽然在高并发场景下有的线程池要慎用），几乎所有需要异步或者并发的执行任务的程序都可以使用线程池。总结下，可以带来3个好处。</p>
<p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
<p>第二：提高响应速度。当任务到达时，任务可以不需要等线程创建就能立即执行。</p>
<p>第三：提高线程的可管理性。无限制创建线程会消耗系统资源、降低系统稳定性，使用线程池可以进行统一分配、调优和监控。</p>
<h2 id="1-1-线程池的实现原理"><a href="#1-1-线程池的实现原理" class="headerlink" title="1.1 线程池的实现原理"></a>1.1 线程池的实现原理</h2><p>当往线程池提交一个任务之后，线程池是如何处理这个任务的？下面来看线程池主要处理流程。</p>
<h3 id="1-1-1-主要处理流程"><a href="#1-1-1-主要处理流程" class="headerlink" title="1.1.1 主要处理流程"></a>1.1.1 主要处理流程</h3><p><img src="/img/in-post/1574908942078.png" alt></p>
<p>当提交一个新任务到线程池时，线程池的处理流程如下：</p>-->
    <!--</div>-->
  </a>

</div>

  
  
  <div class="archive" >
  <a class="post-go" href="/2019/11/27/ODL-RPC-module/">
    <div>
      <span class="date">
        11-27
      </span>
      <span class="slash">/</span>
      【opendaylight】——MD-SAL RPC源码概览
    </div>

    <!--<div class="excerpt">-->
      <!--<h1 id="一、源码概览"><a href="#一、源码概览" class="headerlink" title="一、源码概览"></a>一、源码概览</h1><h2 id="1-总体模块概览"><a href="#1-总体模块概览" class="headerlink" title="1.总体模块概览"></a>1.总体模块概览</h2><p>OpenDaylight MD-SAL支持两种RPC服务，即BI RPC服务和BA RPC服务，在AC中常用的通过Yang定义RPC生成Java接口的方式是BA服务。在MD-SAL中服务的发现、注册都是基于BI服务来实现的，BA服务则统一转换成BI服务来处理。</p>
<p><img src="/img/in-post/1578029090431.png" alt></p>
<ul>
<li><p>sal-core-api：定义了BI RPC服务的注册、调用接口。</p>
</li>
<li><p>sal-broker-impl：实现了BI RPC服务的注册、调用。</p>
</li>
<li><p>sal-binding-api：定义了BA RPC服务的注册、调用接口。</p>
</li>
<li><p>sal-binding-broker-impl：实现了BA RPC服务的注册、调用，实际的注册、调用操作都通过adapter将BA服务封装成BI服务代理到BI RPC服务中心。</p>
</li>
<li><p>sal-remoterpc-connector：实现了多个ODL节点中BI RPC服务信息的同步，以及跨进程的服务调用。</p>
<h2 id="2-分模块实现"><a href="#2-分模块实现" class="headerlink" title="2.分模块实现"></a>2.分模块实现</h2><h3 id="BI-RPC和BA-RPC服务中心的实现"><a href="#BI-RPC和BA-RPC服务中心的实现" class="headerlink" title="BI RPC和BA RPC服务中心的实现"></a>BI RPC和BA RPC服务中心的实现</h3></li>
</ul>
<p><img src="/img/in-post/1578029209816.png" alt></p>
<ul>
<li><p>DOMRpcProviderService：定义了BI RPC服务的注册接口。</p>
</li>
<li><p>DOMRpcService：定义了BI RPC服务的调用和服务增删的监听接口。</p>
</li>
<li><p>DOMRpcAvailabilityListener：BI RPC服务新增和删除的监听接口。</p>
</li>
<li><p>DOMRpcRouter：实现了BI RPC服务的注册、调用和服务增加的监听回调。</p>
</li>
<li><p>RpcConsumerRegistry：定义了BA RPC服务的查询接口。</p>
</li>
<li><p>RouteChangePublisher：定义了BA RPC服务的变更监听接口。</p>
</li>
<li><p>RpcProviderRegistry：定义了BA RPC服务的注册接口。</p>
</li>
<li><p>BindingDOMRpcServiceAdapter：实现了BA RPC服务的查询，依赖DOMRpcService，将对BA RPC的调用转换为调用DOMRpcService。</p>
</li>
<li><p>BindingDOMRpcProviderServiceAdapter：依赖DOMRpcProviderService，将BA RPC封装为DOMRpcImplementation注册到DOMRpcProviderService。</p>
</li>
<li><p>HeliumRpcProviderRegistry：聚合BindingDOMRpcServiceAdapter</p>
</li>
<li><p>BindingDOMRpcProviderServiceAdapter提供完整的BA RPC服务的注册、查询功能。</p>
</li>
</ul>
<h3 id="BI-RPC服务跨进程注册和调用的实现"><a href="#BI-RPC服务跨进程注册和调用的实现" class="headerlink" title="BI RPC服务跨进程注册和调用的实现"></a>BI RPC服务跨进程注册和调用的实现</h3><p><img src="/img/in-post/1578029278164.png" alt></p>
<p>RPC跨进程注册和调用的主要类</p>-->
    <!--</div>-->
  </a>

</div>

  
  
  <div class="archive" >
  <a class="post-go" href="/2019/11/27/ODL-mdsal-codereview/">
    <div>
      <span class="date">
        11-27
      </span>
      <span class="slash">/</span>
      【opendaylight】——MD-SAL服务总线RPC服务源码分析
    </div>

    <!--<div class="excerpt">-->
      <!--<h1 id="1、RPC服务简单介绍"><a href="#1、RPC服务简单介绍" class="headerlink" title="1、RPC服务简单介绍"></a>1、RPC服务简单介绍</h1><p>ODL平台下MD-SAL服务总线支持两类RPC服务的注册与调用，分别是Global RPC和Routed RPC，其中，Global RPC是一个控制器节点内部本进程内的调用，Routed RPC支持在控制器集群内部不同控制器节点之间跨进程调用(当然也支持同一进程内调用)，这两类RPC服务都需要注册到MD-SAL服务总线上，本文档主要总结这两类RPC服务是怎么注册到MD-SAL服务总线上以及从服务总线上获取服务调用接口的主要流程。</p>
<p><img src="/img/in-post/1578029380086.png" alt></p>
<h1 id="2、注册RPC服务（Global-RPC）"><a href="#2、注册RPC服务（Global-RPC）" class="headerlink" title="2、注册RPC服务（Global RPC）"></a>2、注册RPC服务（Global RPC）</h1><p><img src="/img/in-post/1578029399834.png" alt></p>
<p>说明：</p>
<ul>
<li>1、BA方式启动时在onSessionInitiated中获取到ProviderContext，配置子系统启动时在createInstance中获取到RootBindingAwareBroker，其他业务通过调用对应的ProviderContext或者RootBindingAwareBroker的addRpcImplementation(Class<t>,T)方法将服务注册到MD-SAL的服务总线上，所有的服务都会在BindingDOMRpcProviderServiceAdapter中创建出一个实现了DOMRpcImplementation接口的BindingDOMRpcImplementationAdapter实例，实例内部保存了接口实际注册的实例以及接口所有RPC方法对应的一个RpcMethodInvoker的Map(存储在AbstractMappedRpcInvoker中)，并将BindingDOMRpcImplementationAdapter实例添加到DOMRpcRouter中的DOMRpcRoutingTable内，存储在一个全局的Map&lt;SchemaPath, AbstractDOMRpcRoutingTableEntry&gt;中value对应的GlobalDOMRpcRoutingTableEntry中Map&lt;YangInstanceIdentifier, List<domrpcimplementation>&gt; 内的List<domrpcimplementation>&gt; 中(一个RPC接口可能被注册多次，一个RP接口也可能绑定多个YangInstanceIdentifier)。</domrpcimplementation></domrpcimplementation></t></li>
<li>2、系统中之前未注册的RPC方法都会触发RpcListener的onRpcAvailable接口来将所有的RPC信息添加到本地的路由表信息(RpcRegistry中的localBucket)中，用于RPC集群节点之间的路由表信息同步。</li>
</ul>
<h1 id="3、注册RPC服务（Routed-RPC）"><a href="#3、注册RPC服务（Routed-RPC）" class="headerlink" title="3、注册RPC服务（Routed RPC）"></a>3、注册RPC服务（Routed RPC）</h1><p><img src="/img/in-post/1578029444552.png" alt></p>
<ul>
<li>说明：BA方式启动时在onSessionInitiated中获取到ProviderContext，配置子系统启动时在createInstance中获取到RootBindingAwareBroker，其他业务通过调用对应的ProviderContext或者RootBindingAwareBroker的addRoutedRpcImplementation(Class<t>, T)方法添加Routed RPC的实现，在HeliumRpcProviderRegistry中会直接返回一个CompositeRoutedRpcRegistration的实例,实例内存储了注册的RPC接口的相关信息。</t></li>
</ul>-->
    <!--</div>-->
  </a>

</div>

  
  
  <div class="archive" >
  <a class="post-go" href="/2019/11/27/java-concurrency-container-Executor/">
    <div>
      <span class="date">
        11-27
      </span>
      <span class="slash">/</span>
      【并发容器和框架】四、Executor框架
    </div>

    <!--<div class="excerpt">-->
      <!--<p>@[toc]<br>上文讲了，如果为每个任务创建一个新线程来执行，线程的创建和销毁要消耗大量的计算资源。Java的线程既是工作单元，也是执行机制。从JDK 5开始，把工作单元和执行机制分离开来。工作单元包括Runnable和Callable，而执行机制由Executor框架提供。</p>
<h1 id="1-Executor框架简介"><a href="#1-Executor框架简介" class="headerlink" title="1. Executor框架简介"></a>1. Executor框架简介</h1><h2 id="1-1-Executor框架的两级调度模型"><a href="#1-1-Executor框架的两级调度模型" class="headerlink" title="1.1 Executor框架的两级调度模型"></a>1.1 Executor框架的两级调度模型</h2><p>在HotSpot VM的线程模型中，Java线程被一对一映射为本地操作系统线程。Java线程启动时会创建一个本地操作系统线程;当该Java线程终止时，这个操作系统线程也会被回收。操作系统会调度所有线程并将它们分配给可用的CPU。</p>
<p>在上层，Java多线程程序通常应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。如这种两级调度模型示意图见下一节。</p>
<p>从图中可以看出，应用程序通过Executor框架控制上层的调度；而下层的调度由操作系统内核控制，下层的调度不受应用程序的控制。</p>
<h2 id="1-2-Executor框架的结构与成员"><a href="#1-2-Executor框架的结构与成员" class="headerlink" title="1.2 Executor框架的结构与成员"></a>1.2 Executor框架的结构与成员</h2><p><img src="/img/in-post/image-20191222214449679.png" alt></p>
<h3 id="1-2-1-Executor框架的结构"><a href="#1-2-1-Executor框架的结构" class="headerlink" title="1.2.1 Executor框架的结构"></a>1.2.1 Executor框架的结构</h3><p>Executor框架主要由3大部分：</p>-->
    <!--</div>-->
  </a>

</div>

  
  
  <div class="archive" >
  <a class="post-go" href="/2019/11/27/NLP-Gradient-Descent/">
    <div>
      <span class="date">
        11-27
      </span>
      <span class="slash">/</span>
      【NLP】一、线性回归与随机梯度下降法
    </div>

    <!--<div class="excerpt">-->
      <!--<p>在NLP的学习中，我们了解熵、信息熵、交叉熵的基础概念，通过将熵（信息量的度量）的计算转换为概率模型的计算，然后介绍了在一些语料库中的样本中，计算出一些词与其他词同时出现在一个句子或者短语的概率，引入了N-gramm的概念，但是N个词的N-gramm的概率非常难以计算而且计算出的概率很小，因此一般使用bigram model计算（即认为当前词只与前面那个词相关）但这种方式相对不够精确。</p>
<p>如果我们把一个词放在整改语料库里去看，并利用当前语料库的输入（one hot represetation）通过神经网络模型计算损失函数的最优解（参数众多），以此来预测其他词出现的情况，这里就会用到一个基础的线性回归的方法——随机梯度法的概念。神经网络是通用方法，而基础就是基于线性回归的方法，线性回归最基础的方法就是梯度下降，因此理解线性回归以及他的基本方法随机梯度下降非常重要。</p>
<p>本篇文章就以机器学习中常用的线性回归的基本方法——随机梯度下降进行总结。</p>
<p>下面就一个实际的线性回归问题：<strong>如何预测房价</strong>作为引入。</p>
<h1 id="一、问题：如何预测房价？"><a href="#一、问题：如何预测房价？" class="headerlink" title="一、问题：如何预测房价？"></a>一、问题：如何预测房价？</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="/img/in-post/image-20200102230850144.png" alt></p>
<p>已知一些面积对应的房价的样本数据，利用这些样本数据预测其他面积的房价。</p>
<p>这是一个监督学习的例子，因为例子中每个点都有明确的“正确答案”，如1000平的房子在170W美金，预测出的某个平方的房子也一定有明确的价钱。同时这也是监督学习中典型的回归问题，输出是一个具体指（当然另外一种典型的监督学习问题是分类，用来预测离散值的输出）。</p>
<h2 id="训练集"><a href="#训练集" class="headerlink" title="训练集"></a>训练集</h2>-->
    <!--</div>-->
  </a>

</div>

  
  
  <div class="archive" >
  <a class="post-go" href="/2019/11/27/Json Facet/">
    <div>
      <span class="date">
        11-27
      </span>
      <span class="slash">/</span>
      【Solr应用】——Json Facet使用总结
    </div>

    <!--<div class="excerpt">-->
      <!--<h1 id="Faceted-Search"><a href="#Faceted-Search" class="headerlink" title="Faceted Search"></a>Faceted Search</h1><h2 id="Metric-Example"><a href="#Metric-Example" class="headerlink" title="Metric Example"></a>Metric Example</h2><pre><code class="java">curl http://192.168.3.13:31121/xxx/PATENT/query -d &#39;
  q=*:*&amp;
  json.facet={
    &quot;AVG_CITE_COUNT&quot;:&quot;avg(CITE_COUNT)&quot;,
    &quot;NUM_IN_COUNTRY&quot;:&quot;unique(IN_COUNTRY)&quot;,
    &quot;MEDIA_CLAIM_COUNT&quot;:&quot;percentile(CLAIM_COUNT,50)&quot;
  }
&#39;</code></pre>
<p>响应:</p>
<pre><code class="java">&quot;facets&quot;:{
    &quot;count&quot;:661044,
    &quot;MEDIA_CLAIM_COUNT&quot;:19.0,
    &quot;AVG_CITE_COUNT&quot;:13.03796393q=*:*&amp;4739052,
    &quot;NUM_IN_COUNTRY&quot;:185}</code></pre>
<h2 id="Bucketing-Facet-Example"><a href="#Bucketing-Facet-Example" class="headerlink" title="Bucketing Facet Example"></a>Bucketing Facet Example</h2><pre><code class="java">curl http://192.168.3.13:31121/xxx/PATENT/query -d &#39;
  q=*:*&amp;
  json.facet={
    categories:{
      type:terms,
      field:APD_YEARMONTHDAY,
      limit:10
    }
  }
&#39;</code></pre>
<p>响应：</p>
<pre><code class="java">  &quot;facets&quot;:{
    &quot;count&quot;:661044,
    &quot;categories&quot;:{
      &quot;buckets&quot;:[{
          &quot;val&quot;:20000524,
          &quot;count&quot;:1167},
        {
          &quot;val&quot;:20160923,
          &quot;count&quot;:935},
        {
          &quot;val&quot;:20151218,
          &quot;count&quot;:857},
        {
          &quot;val&quot;:20160331,
          &quot;count&quot;:838},
        {
          &quot;val&quot;:20160129,
          &quot;count&quot;:702},
        {
          &quot;val&quot;:20160630,
          &quot;count&quot;:595},
        {
          &quot;val&quot;:20160729,
          &quot;count&quot;:553},
        {
          &quot;val&quot;:20150210,
          &quot;count&quot;:459},
        {
          &quot;val&quot;:20161216,
          &quot;count&quot;:459},
        {
          &quot;val&quot;:20160527,
          &quot;count&quot;:454}]
    }}}</code></pre>
<h2 id="Making-a-Facet-Request"><a href="#Making-a-Facet-Request" class="headerlink" title="Making a Facet Request"></a>Making a Facet Request</h2>-->
    <!--</div>-->
  </a>

</div>

  
  
  <div class="archive" >
  <a class="post-go" href="/2019/11/06/java-concurrency-container-ForkJoin/">
    <div>
      <span class="date">
        11-06
      </span>
      <span class="slash">/</span>
      【并发容器和框架】二、Fork/Join框架
    </div>

    <!--<div class="excerpt">-->
      <!--<p>@[toc]</p>
<h1 id="1-什么是Fork-Join框架"><a href="#1-什么是Fork-Join框架" class="headerlink" title="1.什么是Fork/Join框架"></a>1.什么是Fork/Join框架</h1><p>Fork/Join框架是Java 7提供的一个并行执行任务的框架，是一个把大小任务分割成若干小任务，最终汇总每个小人物结果后得到大任务结果的框架。</p>
<p>Fork就是把一个大任务切分成若干个小任务并行执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。比如计算1+2….+1000，可以分割成10个子任务，每个子任务分别对1000个数进行求和，最终汇总这10个子任务的结果。流程如下：</p>
<p><img src="/img/in-post/image-20191108011932771.png" alt></p>
<h1 id="2-工作窃取算法"><a href="#2-工作窃取算法" class="headerlink" title="2.工作窃取算法"></a>2.工作窃取算法</h1><p>在需要做比较大的任务时，可以把任务分割成若干互不依赖的子任务，减少线程间的竞争。这些子任务被放到不同的队列，并为每个队列创建一个单独的线程来执行队列里的任务。有些线程执行任务比较快，就会”窃取”其他线程队里中的任务帮助干活。为了减少窃取与其他线程的之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列头拿任务，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>
<p><img src="/img/in-post/image-20191116171122073.png" alt></p>
<ul>
<li>工作窃取算法的优点：充分利用线程进行并行计算，减少了线程间的竞争。</li>
<li>工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个多段队列。</li>
</ul>
<h1 id="3-Fork-Join框架的设计"><a href="#3-Fork-Join框架的设计" class="headerlink" title="3.Fork/Join框架的设计"></a>3.Fork/Join框架的设计</h1>-->
    <!--</div>-->
  </a>

</div>

  
  
  <div class="archive" >
  <a class="post-go" href="/2019/10/30/Algorithms_AL_Sort/">
    <div>
      <span class="date">
        10-30
      </span>
      <span class="slash">/</span>
      【数据结构与算法】-【算法】排序
    </div>

    <!--<div class="excerpt">-->
      <!--<p>@[toc]<br>本文将总结众多排序算法中的一小撮，也是最经典、最常用的：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。依据时间复杂度可以分为三类，我将按照三次来总结。</p>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度</th>
<th>时候基于比较</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡、插入、选择</td>
<td>O(n^2)</td>
<td>是</td>
</tr>
<tr>
<td>快排、归并</td>
<td>O(nlogn)</td>
<td>是</td>
</tr>
<tr>
<td>桶、计数、基数</td>
<td>O(n)</td>
<td>否</td>
</tr>
</tbody></table>
<h1 id="分析排序算法"><a href="#分析排序算法" class="headerlink" title="分析排序算法"></a>分析排序算法</h1><p>学习排序算法，除了要了解算法原理、代码实现、更重要的是学会如何评价、分析一个排序算法。那分析算法应该从哪几个方面入手？</p>
<h2 id="排序算法的执行效率"><a href="#排序算法的执行效率" class="headerlink" title="排序算法的执行效率"></a>排序算法的执行效率</h2><ol>
<li><p>最好情况、最坏情况、平均情况时间复杂度</p>
</li>
<li><p>时间复杂度的系数、常数、低阶</p>
<p>时间复杂度反映的是数据量很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但实际的软件开发中，我们排序的可能是10个、100个、1000个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，就要把常数、系数、低阶也考虑进来。</p>
</li>
<li><p>比较次数和交换（或移动）次数</p>
<p>基于比较的算法执行过程涉及两个操作，比较元素大小和元素交换或移动。在分析效率的时候，应该把比较次数和交换次数也考虑进去。</p>
</li>
</ol>
<h2 id="排序算法的内存消耗"><a href="#排序算法的内存消耗" class="headerlink" title="排序算法的内存消耗"></a>排序算法的内存消耗</h2><p>算法内存消耗可以通过空间复杂度衡量，排序算法也不例外。<strong>原地排序</strong>，就是特指空间复杂度是O（1）的排序算法。这篇文章马上要说的都是原地排序的算法。</p>
<h2 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h2><p>针对排序算法还有个重要指标就是<strong>稳定性</strong>。是说，如果待排序的序列存在值相等，经过排序后，相等元素之间的原有的先后顺序不变。</p>-->
    <!--</div>-->
  </a>

</div>

  
  
  <div class="archive" >
  <a class="post-go" href="/2019/10/27/java-concurrency-container-ConcurrentHashMap/">
    <div>
      <span class="date">
        10-27
      </span>
      <span class="slash">/</span>
      【并发容器和框架】一、CocurrentHashMap的实现原理与使用
    </div>

    <!--<div class="excerpt">-->
      <!--<p>@[toc]</p>
<h1 id="为什么引入ConcurrentHashMap"><a href="#为什么引入ConcurrentHashMap" class="headerlink" title="为什么引入ConcurrentHashMap"></a>为什么引入ConcurrentHashMap</h1><p>在并发编程中使用HashMap可能导致程序死循环。而使用线程安全的HashTable效率又非常低下，基于以上两个原因，便有了ConcurrentHash的出现。</p>
<ul>
<li><p>线程不安全的HashMap</p>
<p>在多线程环境下，使用HashMap进行put操作会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。</p>
</li>
<li><p>效率低下的的HashTable</p>
<p>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。</p>
</li>
<li><p>ConcurrentHashMap的锁分段技术可有效提升并发率</p>
<p>HashTable在高并发下的效率低下的原因是因为所有访问HashTable的线程必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争。</p>
<p>存储数据时分成一段段存储，每一段分配一把锁，这样当一个线程访问其中一个段数据时，其他段数据依然可以被其他线程访问。</p>
</li>
</ul>
<p>  分段锁是JDK1.7及其之前的实现技术，JDK1.8并没有使用分段锁技术。</p>
<h1 id="JDK-1-7的ConcurrentHashMap"><a href="#JDK-1-7的ConcurrentHashMap" class="headerlink" title="JDK 1.7的ConcurrentHashMap"></a>JDK 1.7的ConcurrentHashMap</h1><p>ConcurrentHashMap的设计一直在演进中，JDK 1.7和JDK 1.8的ConcurrentHashMap实现存在巨大的差异，公司现在使用的是JDK 1.8，因此我们着重分析JDK 1.8，在此之前1.7也先介绍下。</p>
<h2 id="JDK-1-7的ConcurrentHashMap的结构"><a href="#JDK-1-7的ConcurrentHashMap的结构" class="headerlink" title="JDK 1.7的ConcurrentHashMap的结构"></a>JDK 1.7的ConcurrentHashMap的结构</h2><p>主要结构由：</p>
<ul>
<li>分离锁 <strong>Segment</strong>、Segment内部集成一个<strong>HashEntry</strong>的数组。<ul>
<li>Segment是一种可重入锁，一个ConcurrentHashMap包含一个Segment数组，一个Segment包含一个HashEntry数组。Segment的结构与HashMap类似是一种数组和链表的结构。</li>
<li>每个HashEntry是一个链表结构的元素。</li>
</ul>
</li>
<li>HashEntry内部使用volatile的value字段来保证可见性，也利用了不可变对象的机制以改进利用Unsafe提供的底层能力，比如volatile access，直接完成部分操作，以优化性能，毕竟Unsafe中的很多操作是JVM intrinsic优化过的。</li>
</ul>-->
    <!--</div>-->
  </a>

</div>

  
  
  <div class="archive" >
  <a class="post-go" href="/2019/10/22/Algorithms_DS_DS_Link/">
    <div>
      <span class="date">
        10-22
      </span>
      <span class="slash">/</span>
      【数据结构与算法】-【数据结构篇】链表
    </div>

    <!--<div class="excerpt">-->
      <!--<p>@[toc]</p>
<h1 id="五花八门的链表结构"><a href="#五花八门的链表结构" class="headerlink" title="五花八门的链表结构"></a>五花八门的链表结构</h1><p>相比数组，线性表中的链表是一种稍复杂的数据结构。</p>
<p>先看<strong>底层的存储结构</strong>，</p>
<p>数组需要一块<strong>连续的内存空间</strong>，对内存要求比较高。如果没有连续的足够内存会申请失败。</p>
<p>链表相反，<strong>不需要一块连续的内存空间</strong>，通过“指针”将一组<strong>零散的内存块</strong>串联起来。</p>
<p><img src="/img/in-post/1571713260510.png" alt></p>
<p>常用的链表主要有：<strong>单链表、双向链表、循环链表（包括双向循环链表）</strong>。</p>
<h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><p><img src="/img/in-post/1571715568453.png" alt></p>-->
    <!--</div>-->
  </a>

</div>


  </div></section>

    </div>

    
      <nav class="page-nav text-center">
          <span class="page-number current">1</span><a class="page-number" href="/archives/2019/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/archives/2019/page/4/">4</a><a class="extend next" rel="next" href="/archives/2019/page/2/">〉</a>
      </nav>
    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" href="https://github.com/fooying" target="_blank">GitHub</a> |
        <a class="bottom-item" href="/links">友情链接</a> |
        <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> |
        <a class="bottom-item" href="https://github.com/fooying/hexo-theme-xoxo-plus" target="_blank">Theme xoxo-plus</a> |
        <a class="bottom-item" href="/atom.xml">RSS</a>
    </div>
</footer>

  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



  
<script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
</script>


</body>
</html>
