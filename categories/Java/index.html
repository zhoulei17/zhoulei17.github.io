
<!DOCTYPE html>
<html lang="en">


<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020"/>
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="" />
  

  
    <meta name="description" content="Hexo," />
  
  
  
  <link rel="icon" type="image/x-icon" href="/images/footer-logo.png">
  
  <title>category: Java [ Hexo ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    
    <span class="title" style="text-transform:none">Hexo</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            
              <li class="pure-menu-item"><a href="/" class="pure-menu-link">Home</a></li>
            
          
      
          
            
              <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover actived">
            
              <a href="#" id="post" class="pure-menu-link">文章</a>
              <ul class="pure-menu-children">
              
                  
                    <li class="pure-menu-item"><a href="/categories" class="pure-menu-link">Categories</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="/archives" style="color:#202020;" class="pure-menu-link">Archives</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="/tags" style="color:#202020;" class="pure-menu-link">Tags</a></li>
                  
              
              </ul>
            </li>
          
      
          
            
              <li class="pure-menu-item"><a href="/paper" class="pure-menu-link">Papers</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/project" class="pure-menu-link">项目</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/activity" class="pure-menu-link">动态</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/search" class="pure-menu-link">Search</a></li>
            
          
      
  </ul>
   
</nav>

  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      

  
  
    
    
    <section class="post page archives">
      <h3 class="archive-year-wrap">
        <a href="/archives/2019" class="archive-year">
          2019
        </a>
      </h3>
      <div class="archives">
  
  <div class="archive" >
  <a class="post-go" href="/2019/12/23/java-concurrency-container-ThreadPool/">
    <div>
      <span class="date">
        12-23
      </span>
      <span class="slash">/</span>
      【并发容器和框架】三、Java线程池的实现原理和使用
    </div>

    <!--<div class="excerpt">-->
      <!--<h1 id="1-Java线程池的实现原理"><a href="#1-Java线程池的实现原理" class="headerlink" title="1. Java线程池的实现原理"></a>1. Java线程池的实现原理</h1><p>线程池是日常开发中使用最多的并发框架（虽然在高并发场景下有的线程池要慎用），几乎所有需要异步或者并发的执行任务的程序都可以使用线程池。总结下，可以带来3个好处。</p>
<p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
<p>第二：提高响应速度。当任务到达时，任务可以不需要等线程创建就能立即执行。</p>
<p>第三：提高线程的可管理性。无限制创建线程会消耗系统资源、降低系统稳定性，使用线程池可以进行统一分配、调优和监控。</p>
<h2 id="1-1-线程池的实现原理"><a href="#1-1-线程池的实现原理" class="headerlink" title="1.1 线程池的实现原理"></a>1.1 线程池的实现原理</h2><p>当往线程池提交一个任务之后，线程池是如何处理这个任务的？下面来看线程池主要处理流程。</p>
<h3 id="1-1-1-主要处理流程"><a href="#1-1-1-主要处理流程" class="headerlink" title="1.1.1 主要处理流程"></a>1.1.1 主要处理流程</h3><p><img src="/img/in-post/1574908942078.png" alt></p>
<p>当提交一个新任务到线程池时，线程池的处理流程如下：</p>-->
    <!--</div>-->
  </a>

</div>

  
  
  <div class="archive" >
  <a class="post-go" href="/2019/11/27/java-concurrency-container-Executor/">
    <div>
      <span class="date">
        11-27
      </span>
      <span class="slash">/</span>
      【并发容器和框架】四、Executor框架
    </div>

    <!--<div class="excerpt">-->
      <!--<p>@[toc]<br>上文讲了，如果为每个任务创建一个新线程来执行，线程的创建和销毁要消耗大量的计算资源。Java的线程既是工作单元，也是执行机制。从JDK 5开始，把工作单元和执行机制分离开来。工作单元包括Runnable和Callable，而执行机制由Executor框架提供。</p>
<h1 id="1-Executor框架简介"><a href="#1-Executor框架简介" class="headerlink" title="1. Executor框架简介"></a>1. Executor框架简介</h1><h2 id="1-1-Executor框架的两级调度模型"><a href="#1-1-Executor框架的两级调度模型" class="headerlink" title="1.1 Executor框架的两级调度模型"></a>1.1 Executor框架的两级调度模型</h2><p>在HotSpot VM的线程模型中，Java线程被一对一映射为本地操作系统线程。Java线程启动时会创建一个本地操作系统线程;当该Java线程终止时，这个操作系统线程也会被回收。操作系统会调度所有线程并将它们分配给可用的CPU。</p>
<p>在上层，Java多线程程序通常应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。如这种两级调度模型示意图见下一节。</p>
<p>从图中可以看出，应用程序通过Executor框架控制上层的调度；而下层的调度由操作系统内核控制，下层的调度不受应用程序的控制。</p>
<h2 id="1-2-Executor框架的结构与成员"><a href="#1-2-Executor框架的结构与成员" class="headerlink" title="1.2 Executor框架的结构与成员"></a>1.2 Executor框架的结构与成员</h2><p><img src="/img/in-post/image-20191222214449679.png" alt></p>
<h3 id="1-2-1-Executor框架的结构"><a href="#1-2-1-Executor框架的结构" class="headerlink" title="1.2.1 Executor框架的结构"></a>1.2.1 Executor框架的结构</h3><p>Executor框架主要由3大部分：</p>-->
    <!--</div>-->
  </a>

</div>

  
  
  <div class="archive" >
  <a class="post-go" href="/2019/11/06/java-concurrency-container-ForkJoin/">
    <div>
      <span class="date">
        11-06
      </span>
      <span class="slash">/</span>
      【并发容器和框架】二、Fork/Join框架
    </div>

    <!--<div class="excerpt">-->
      <!--<p>@[toc]</p>
<h1 id="1-什么是Fork-Join框架"><a href="#1-什么是Fork-Join框架" class="headerlink" title="1.什么是Fork/Join框架"></a>1.什么是Fork/Join框架</h1><p>Fork/Join框架是Java 7提供的一个并行执行任务的框架，是一个把大小任务分割成若干小任务，最终汇总每个小人物结果后得到大任务结果的框架。</p>
<p>Fork就是把一个大任务切分成若干个小任务并行执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。比如计算1+2….+1000，可以分割成10个子任务，每个子任务分别对1000个数进行求和，最终汇总这10个子任务的结果。流程如下：</p>
<p><img src="/img/in-post/image-20191108011932771.png" alt></p>
<h1 id="2-工作窃取算法"><a href="#2-工作窃取算法" class="headerlink" title="2.工作窃取算法"></a>2.工作窃取算法</h1><p>在需要做比较大的任务时，可以把任务分割成若干互不依赖的子任务，减少线程间的竞争。这些子任务被放到不同的队列，并为每个队列创建一个单独的线程来执行队列里的任务。有些线程执行任务比较快，就会”窃取”其他线程队里中的任务帮助干活。为了减少窃取与其他线程的之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列头拿任务，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>
<p><img src="/img/in-post/image-20191116171122073.png" alt></p>
<ul>
<li>工作窃取算法的优点：充分利用线程进行并行计算，减少了线程间的竞争。</li>
<li>工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个多段队列。</li>
</ul>
<h1 id="3-Fork-Join框架的设计"><a href="#3-Fork-Join框架的设计" class="headerlink" title="3.Fork/Join框架的设计"></a>3.Fork/Join框架的设计</h1>-->
    <!--</div>-->
  </a>

</div>

  
  
  <div class="archive" >
  <a class="post-go" href="/2019/10/27/java-concurrency-container-ConcurrentHashMap/">
    <div>
      <span class="date">
        10-27
      </span>
      <span class="slash">/</span>
      【并发容器和框架】一、CocurrentHashMap的实现原理与使用
    </div>

    <!--<div class="excerpt">-->
      <!--<p>@[toc]</p>
<h1 id="为什么引入ConcurrentHashMap"><a href="#为什么引入ConcurrentHashMap" class="headerlink" title="为什么引入ConcurrentHashMap"></a>为什么引入ConcurrentHashMap</h1><p>在并发编程中使用HashMap可能导致程序死循环。而使用线程安全的HashTable效率又非常低下，基于以上两个原因，便有了ConcurrentHash的出现。</p>
<ul>
<li><p>线程不安全的HashMap</p>
<p>在多线程环境下，使用HashMap进行put操作会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。</p>
</li>
<li><p>效率低下的的HashTable</p>
<p>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。</p>
</li>
<li><p>ConcurrentHashMap的锁分段技术可有效提升并发率</p>
<p>HashTable在高并发下的效率低下的原因是因为所有访问HashTable的线程必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争。</p>
<p>存储数据时分成一段段存储，每一段分配一把锁，这样当一个线程访问其中一个段数据时，其他段数据依然可以被其他线程访问。</p>
</li>
</ul>
<p>  分段锁是JDK1.7及其之前的实现技术，JDK1.8并没有使用分段锁技术。</p>
<h1 id="JDK-1-7的ConcurrentHashMap"><a href="#JDK-1-7的ConcurrentHashMap" class="headerlink" title="JDK 1.7的ConcurrentHashMap"></a>JDK 1.7的ConcurrentHashMap</h1><p>ConcurrentHashMap的设计一直在演进中，JDK 1.7和JDK 1.8的ConcurrentHashMap实现存在巨大的差异，公司现在使用的是JDK 1.8，因此我们着重分析JDK 1.8，在此之前1.7也先介绍下。</p>
<h2 id="JDK-1-7的ConcurrentHashMap的结构"><a href="#JDK-1-7的ConcurrentHashMap的结构" class="headerlink" title="JDK 1.7的ConcurrentHashMap的结构"></a>JDK 1.7的ConcurrentHashMap的结构</h2><p>主要结构由：</p>
<ul>
<li>分离锁 <strong>Segment</strong>、Segment内部集成一个<strong>HashEntry</strong>的数组。<ul>
<li>Segment是一种可重入锁，一个ConcurrentHashMap包含一个Segment数组，一个Segment包含一个HashEntry数组。Segment的结构与HashMap类似是一种数组和链表的结构。</li>
<li>每个HashEntry是一个链表结构的元素。</li>
</ul>
</li>
<li>HashEntry内部使用volatile的value字段来保证可见性，也利用了不可变对象的机制以改进利用Unsafe提供的底层能力，比如volatile access，直接完成部分操作，以优化性能，毕竟Unsafe中的很多操作是JVM intrinsic优化过的。</li>
</ul>-->
    <!--</div>-->
  </a>

</div>

  
  
  <div class="archive" >
  <a class="post-go" href="/2019/09/01/2019-9-01-java-concurrency-mutex-atomic/">
    <div>
      <span class="date">
        09-01
      </span>
      <span class="slash">/</span>
      【线程互斥篇】六、无锁方案-原子操作的实现原理
    </div>

    <!--<div class="excerpt">-->
      <!--<p>@[toc]</p>
<h1 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h1><p>在计算机硬件优化导致的3大BUG源头中，其中有一大源头就是原子性的问题，见<a href="[http://zhoulei.site/2019/04/11/java-concurreny-concept-3Bug/#bug%E7%9A%84%E6%BA%90%E5%A4%B4%E4%BA%8C%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98](http://zhoulei.site/2019/04/11/java-concurreny-concept-3Bug/#bug的源头二线程切换带来的原子性问题)">线程切换带来的原子性问题</a>，解决原子性问题的一大方案是<strong>1）有锁方案：synchronized或者互斥锁Lock</strong>，当然这种锁有一个缺陷：需要加锁、解锁、本身加锁、释放锁性能消耗大，而且拿不到锁的线程还会进入阻塞状态，进而触发线程切换，线程切换对性能的消耗也很大。</p>
<p>当然还有一种<strong>2）无锁方案就是CAS自旋来实现变量的并发操作的原子操作</strong>。下面就来详细讲下CPU的原子操作并引入CAS指令到Java中来实现Java的原子操作，并且Java提供了Atomic包的多个原子操作的封装。</p>
<p>下面这篇博客是要来说清楚Java解决原子性问题</p>
<h1 id="原子操作的实现原理"><a href="#原子操作的实现原理" class="headerlink" title="原子操作的实现原理"></a>原子操作的实现原理</h1><h2 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h2><table>
<thead>
<tr>
<th>术语名称</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>缓存行</td>
<td>缓存的最小操作单元</td>
</tr>
<tr>
<td>比较并交换</td>
<td>CAS操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了则不交换</td>
</tr>
<tr>
<td>CPU流水线</td>
<td>CPU流水线的工作方式就像工业生产上的装配流水线，在CPU中由5<del>6个不同功能的电路单元组成一条指令处理流水线，然后将一条X86指令分成5</del>6步后再由这些电路单元分别执行，这样就能实现在一个CPU时钟周期完成一条指令，因此提高了CPU的运算速度。</td>
</tr>
<tr>
<td>内存顺序冲突</td>
<td>内存顺序冲突一般是由假共享引起的，假共享是指多个CPU同时修改同一个缓存行的不同部分而引起其中一个CPU的操作无效，当出现这个内存顺序冲突时，CPU必须清空流水线</td>
</tr>
</tbody></table>
<h2 id="CPU如何实现原子操作"><a href="#CPU如何实现原子操作" class="headerlink" title="CPU如何实现原子操作"></a>CPU如何实现原子操作</h2><p>32位IA-32 CPU使用基于<strong>缓存加锁、总线加锁</strong>的方式实现多处理器之间的原子操作。</p>-->
    <!--</div>-->
  </a>

</div>

  
  
  <div class="archive" >
  <a class="post-go" href="/2019/08/23/2019-8-23-java-concurrency-mutex-final/">
    <div>
      <span class="date">
        08-23
      </span>
      <span class="slash">/</span>
      【线程互斥篇】五、无锁方案-不可变性final与内存语义
    </div>

    <!--<div class="excerpt">-->
      <!--<p>@[toc]</p>
<h1 id="不可变性模型与final"><a href="#不可变性模型与final" class="headerlink" title="不可变性模型与final"></a>不可变性模型与final</h1><p>见<a href="https://zhoulei17.github.io/2019/05/15/java-concurreny-how-to-dev-objshare/" target="_blank" rel="noopener">并发线程共享变量的安全性问题</a>，前面讲了解决并发共享变量的问题除了采用互斥访问外使用volatile、原子类来解决可见性与原子等特定问题场景下的方案。其中，synchronized、lock方案是有锁方案，而volatile、Atomic方案为无锁方案，还有一种无锁方案是使用对象不可变特性避免线程不安全，也能在一定场景下解决并发线程安全问题。在这篇文章中的<a href="https://zhoulei17.github.io/2019/05/15/java-concurreny-how-to-dev-objshare/#4不变性final" target="_blank" rel="noopener">不变性章节</a>也说明了通过使对象不可变解决共享变量同步的问题。</p>
<p>其中文章<a href="https://time.geekbang.org/column/article/92856" target="_blank" rel="noopener">利用不可变模式解决并发问题</a>通过例子很好的总结了final的应用。</p>
<h1 id="final的内存语义"><a href="#final的内存语义" class="headerlink" title="final的内存语义"></a>final的内存语义</h1><p>和前面介绍的锁和volatile相比，对final域的读和写更像是普通的变量的变量访问。下面将介绍final域的内存语义。</p>
<h2 id="final域的重排序规则"><a href="#final域的重排序规则" class="headerlink" title="final域的重排序规则"></a>final域的重排序规则</h2><p>对于final域，编译器和处理器要遵守两个重排序规则。</p>
<ol>
<li>在构造函数内对一个final域的写入，与随后对这个被构造对象的引用赋值给一个引用变量，这两个操作不能重排序。</li>
<li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</li>
</ol>
<p>通过如下示例代码说明这两个规则：</p>-->
    <!--</div>-->
  </a>

</div>

  
  
  <div class="archive" >
  <a class="post-go" href="/2019/08/16/2019-8-16-java-concurrency-mutex-volatile/">
    <div>
      <span class="date">
        08-16
      </span>
      <span class="slash">/</span>
      【线程互斥篇】四、无锁方案-volatile原理与内存语义
    </div>

    <!--<div class="excerpt">-->
      <!--<p>@[toc]<br>在jdk 1.6之前，synchronized一直被称为重量级锁，随着jdk 1.6对synchronized进行各种优化后，有些情况并不那么重了。</p>
<p>Jdk 1.6为了减少锁获得和释放带来的性能消耗而引入的<strong>偏向锁和轻量级锁，以及锁的存储结构和升级过程</strong>。</p>
<h1 id="volatile的应用"><a href="#volatile的应用" class="headerlink" title="volatile的应用"></a>volatile的应用</h1><p>synchronized和volatile在并发编程中扮演着重要角色，volatile是轻量级锁的synchronized，它在多处理器中保证了共享变量的”可见性”。可见性的意思是当一个线程修改共享变量时，另外一个线程能读到这个修改的值。如果volaitle变量修饰符使用恰当，它比synchronized的使用和执行成本更低，因为<strong>它不会引起线程上下文的切换和调度</strong>。下面将深入分析在硬件层面intel处理器是如何实现volatile的，通过深入分析能帮助我们更好的使用volatile变量。</p>
<h2 id="volatile的定义与实现原理"><a href="#volatile的定义与实现原理" class="headerlink" title="volatile的定义与实现原理"></a>volatile的定义与实现原理</h2><p>Java语言规范第3版中对volatile的定义如下：Java编程语言允许线程访问共享变量，为了确保共享变量能够准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。</p>
<p>如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。</p>
<p>在了解volatile实现原理之前，先看下与其实现原理相关的CPU术语与说明。</p>
<table>
<thead>
<tr>
<th>术语</th>
<th align="left">术语描述</th>
</tr>
</thead>
<tbody><tr>
<td>内存屏障(memory barriers)</td>
<td align="left">是一组处理器指令，用于实现对内存操作的顺序限制</td>
</tr>
<tr>
<td>缓冲行(cache line)</td>
<td align="left">缓存中可以分配的最小存储单元。处理器填写缓线时会加载整个缓存线，需要使用多个主内存读周期</td>
</tr>
<tr>
<td>原子操作(atomic operations)</td>
<td align="left">不可中断的一个或一系列操作</td>
</tr>
<tr>
<td>缓存行填充(cache line fill)</td>
<td align="left">当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个缓存行到适当的缓存（L1 L2 L3的或所有）</td>
</tr>
<tr>
<td>缓存命中(cache hit)</td>
<td align="left">如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存读取</td>
</tr>
<tr>
<td>写命中(write hit)</td>
<td align="left">当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存，这个操作被称为写命中</td>
</tr>
<tr>
<td>写缺失(write misses the cache)</td>
<td align="left">一个有效的缓存行被写入到不存在的内存区域</td>
</tr>
</tbody></table>
<p><strong>volatile是如何来保证可见性的呢？</strong></p>-->
    <!--</div>-->
  </a>

</div>

  
  
  <div class="archive" >
  <a class="post-go" href="/2019/08/11/2019-8-11-java-concurrency-mutex-synchronized/">
    <div>
      <span class="date">
        08-11
      </span>
      <span class="slash">/</span>
      【线程互斥篇】三、有锁方案-synchronized的实现原理与应用
    </div>

    <!--<div class="excerpt">-->
      <!--<p>@[toc]<br>在jdk 1.6之前，synchronized一直被称为重量级锁，随着jdk 1.6对synchronized进行各种优化后，有些情况并不那么重了。</p>
<p>Jdk 1.6为了减少锁获得和释放带来的性能消耗而引入的<strong>偏向锁和轻量级锁，以及锁的存储结构和升级过程</strong>。</p>
<h1 id="synchronized基础"><a href="#synchronized基础" class="headerlink" title="synchronized基础"></a>synchronized基础</h1><p>再来总结一下synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体可以使用一下3中形式：</p>
<ul>
<li>对于普通同步方法，锁是当前实例对象。</li>
<li>对于静态同步方法，锁是当前类的Class对象。</li>
<li>对于同步方法块，锁是synchronized括号中配置的对象。</li>
</ul>
<p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p>
<p><strong>那么锁到底存在哪里?</strong></p>
<p><strong>锁里面会存储什么信息呢</strong></p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>从JVM规范中可以看到，synchronized在JVM理的实现原理：</p>-->
    <!--</div>-->
  </a>

</div>

  
  
  <div class="archive" >
  <a class="post-go" href="/2019/07/31/2019-7-31-java-concurrency-Mutex-readwritelock/">
    <div>
      <span class="date">
        07-31
      </span>
      <span class="slash">/</span>
      【线程互斥篇】二、有锁方案-读写锁ReadWriteLock——快速使用一个完备的缓存
    </div>

    <!--<div class="excerpt">-->
      <!--<p>@[toc]</p>
<h1 id="读—写锁"><a href="#读—写锁" class="headerlink" title="读—写锁"></a>读—写锁</h1><p>ReentrantLock实现了一种标准的互斥锁：每次最多只有一个线程持有ReentLock，但对于数据完整性来说，互斥通常是一种过于强硬的加强规则，因此也就不必要的限制了并发性。不仅仅限制了”写/写”冲突和”写/读”冲突，但同样也避免了”读/读”冲突。</p>
<p>如果是”读/读”场景，允许多个线程同时访问数据，会提高性能。只要每个线程都能确保读到最新的数据，并且在读取数据时不会有其他线程修改数据，就不会发生问题。</p>
<p>总结，读-写锁：</p>
<blockquote>
<ol>
<li>允许多个线程同时读共享变量</li>
<li>只允许一个线程写共享变量</li>
<li>如果一个写线程正在执行写操作，此时禁止读线程读共享变量。</li>
<li>如果有线程在读共享变量，此时禁止写线程写共享变量。</li>
</ol>
</blockquote>
<p>尽管这两个锁看上去是彼此独立的，但读取锁和写入锁只是读——写锁对象的不同视图。</p>
<pre><code class="java">public interface ReadWriteLock{
  Lock readLock()；
  Lock writeLock();    
}</code></pre>
<p>在读—写锁实现的加锁策略中，允许多个读操作同时进行，但每次中允许一个写操作。与Lock一样，ReadWriteLock可以采用多种不同的实现方式，这些方式在性能、调度保证、获取优先性、公平性以及加锁语义等方面可能有所不同。</p>
<h1 id="性能方面"><a href="#性能方面" class="headerlink" title="性能方面"></a>性能方面</h1>-->
    <!--</div>-->
  </a>

</div>

  
  
  <div class="archive" >
  <a class="post-go" href="/2019/07/29/2019-7-29-java-concurrency-Mutex-lock/">
    <div>
      <span class="date">
        07-29
      </span>
      <span class="slash">/</span>
      【线程互斥篇】一、有锁方案-锁Lock(并发包中的管程)
    </div>

    <!--<div class="excerpt">-->
      <!--<p>@[toc]</p>
<h1 id="管程与Lock"><a href="#管程与Lock" class="headerlink" title="管程与Lock"></a>管程与Lock</h1><p>JDK并发包中内容很多，核心的是其对管程的实现。理论上利用管程几乎可以实现所有的并发工具。在前面写的博客管程中的管程文章。<a href="https://zhoulei17.github.io/2019/05/09/java-concurreny-java-monitor/" target="_blank" rel="noopener">管程——并发编程的万能钥匙</a>,<a href="[https://zhoulei17.github.io/2019/05/09/java-concurreny-system-courrenency/#%E7%AE%A1%E7%A8%8B](https://zhoulei17.github.io/2019/05/09/java-concurreny-system-courrenency/#管程)">从操作系统角度看并发</a>,中已经介绍了管程，可以跳过去看。</p>
<p>本篇文中提到的并发编程领域，有两个核心问题：<strong>互斥与同步(即协作)</strong>，这两大问题，管程都是能够解决的。</p>
<p><strong>Java SDK并发包通过Lock和Condition两个接口来实心管程，其中Lock用于解决互斥问题，Condition用于解决同步问题。</strong></p>
<p><strong>问题：为什么Java本身提供了sychronized也是管程的一种实现，既然已经提供了管程的实现，为什么还要提供Lock这种显式锁的方式？</strong>显然不是重复造轮子，那区别在哪里？</p>
<h1 id="再造管程的理由"><a href="#再造管程的理由" class="headerlink" title="再造管程的理由"></a>再造管程的理由</h1><p>在Java 1.5中sychronized性能不如SDK里面的Lock，但1.6版本后，synchronized做了很多优化，将性能追了上来，所以1.6之后的版本又有人推荐使用了synchronized了。可见性能并不是再造管程的理由。</p>
<p>在死锁的破坏条件中有一个方案：<strong>破坏不可抢占条件</strong>，这个条件在synchronized是不能解决的。因为synchronized申请资源的时候，如果申请不到，线程直接进入阻塞状态，啥都干不了，也释放不了线程已经占用的资源。但我们的希望是：</p>
<blockquote>
<p>对于”不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</p>
</blockquote>-->
    <!--</div>-->
  </a>

</div>


  </div></section>

    </div>

    
      <nav class="page-nav text-center">
          <span class="page-number current">1</span><a class="page-number" href="/categories/Java/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/categories/Java/page/4/">4</a><a class="extend next" rel="next" href="/categories/Java/page/2/">〉</a>
      </nav>
    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" href="https://github.com/fooying" target="_blank">GitHub</a> |
        <a class="bottom-item" href="/links">友情链接</a> |
        <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> |
        <a class="bottom-item" href="https://github.com/fooying/hexo-theme-xoxo-plus" target="_blank">Theme xoxo-plus</a> |
        <a class="bottom-item" href="/atom.xml">RSS</a>
    </div>
</footer>

  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



  
<script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
</script>


</body>
</html>
