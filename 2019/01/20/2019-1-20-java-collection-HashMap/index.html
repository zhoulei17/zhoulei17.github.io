<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"2tongtong.cn","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"always","padding":25,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="概述Hashtable、HashMap、TreeMap都是最常见的一些Map实现，是以键值对的形式存储和操作数据的容器类型。 Hashtable：早期java类库提供的一个 哈希表 实现，同步的，不支持null键和值，由于同步开销，很少被推荐使用。 HashMap：应用更加广泛的哈希表的实现，行为大致与Hashtable一致。主要区别是HashMap不是同步的，支持null键和值等。通常情况下，H">
<meta property="og:type" content="article">
<meta property="og:title" content="【Java集合】-HashMap">
<meta property="og:url" content="2tongtong.cn/2019/01/20/2019-1-20-java-collection-HashMap/index.html">
<meta property="og:site_name" content="Z.L&#39;s blog">
<meta property="og:description" content="概述Hashtable、HashMap、TreeMap都是最常见的一些Map实现，是以键值对的形式存储和操作数据的容器类型。 Hashtable：早期java类库提供的一个 哈希表 实现，同步的，不支持null键和值，由于同步开销，很少被推荐使用。 HashMap：应用更加广泛的哈希表的实现，行为大致与Hashtable一致。主要区别是HashMap不是同步的，支持null键和值等。通常情况下，H">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="/img/in-post/image20190122234040237.png">
<meta property="article:published_time" content="2019-01-19T16:00:00.000Z">
<meta property="article:modified_time" content="2020-03-22T10:10:53.490Z">
<meta property="article:author" content="Zhou Lei">
<meta property="article:tag" content="java">
<meta property="article:tag" content="Collection">
<meta property="article:tag" content="集合">
<meta property="article:tag" content="HashMap">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="/img/in-post/image20190122234040237.png">

<link rel="canonical" href="2tongtong.cn/2019/01/20/2019-1-20-java-collection-HashMap/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>【Java集合】-HashMap | Z.L's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Z.L's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">53</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">58</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="2tongtong.cn/2019/01/20/2019-1-20-java-collection-HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.png">
      <meta itemprop="name" content="Zhou Lei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z.L's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【Java集合】-HashMap
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-20 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-20T00:00:00+08:00">2019-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-22 18:10:53" itemprop="dateModified" datetime="2020-03-22T18:10:53+08:00">2020-03-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E9%9B%86%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">集合</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Hashtable、HashMap、TreeMap都是最常见的一些Map实现，是以键值对的形式存储和操作数据的容器类型。</p>
<p>Hashtable：早期java类库提供的一个 哈希表 实现，同步的，不支持null键和值，由于同步开销，很少被推荐使用。</p>
<p>HashMap：应用更加广泛的哈希表的实现，行为大致与Hashtable一致。主要区别是HashMap不是同步的，支持null键和值等。通常情况下，HashMap进行put、get可以达到常数时间的性能，所以它是绝大部分利用键值对存取场景的首选。</p>
<p>TreeMap：则是基于红黑树的一种提供顺序访问的Map，get put remove之类的操作都是O(log(n))的时间复杂度，具体熟悉由Comparator来决定。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li>桶数组（哈希表）</li>
</ul>
<p>桶数组(Buckets)：数组（Node&lt;K,V&gt; table）和链表结合组成的复合结构，数组被分成一个个桶（bucket），通过hash值决定键值对在这个数组的寻址；hash值相同的键值对，则以链表形式存储，如下面的示意图。如果链表大小超过阈值(TREEIFY_THRESHOLD,8),图中的链表就会被改造成树形结构。 </p>
<p><img data-src="/img/in-post/image20190122234040237.png" alt=""></p>
<ul>
<li><p>数据节点定义</p>
<pre><code class="java">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    final int hash;
    final K key;
    V value;
    Node&lt;K,V&gt; next;
    ...
}</code></pre>
</li>
</ul>
<p>可见是个单向链表节点，而链表数组的定义如下</p>
<ul>
<li><p>链表数组</p>
<pre><code class="java">    /**
     * The table, initialized on first use, and resized as
     * necessary. When allocated, length is always a power of two.
     * (We also tolerate length zero in some operations to allow
     * bootstrapping mechanics that are currently not needed.)
     */
    transient Node&lt;K,V&gt;[] table;</code></pre>
</li>
</ul>
<h2 id="四个特性关注点"><a href="#四个特性关注点" class="headerlink" title="四个特性关注点"></a>四个特性关注点</h2><table>
<thead>
<tr>
<th align="center">关注点</th>
<th align="center">结论</th>
</tr>
</thead>
<tbody><tr>
<td align="center">HashMap是否允许空</td>
<td align="center">Key和Value都允许为空</td>
</tr>
<tr>
<td align="center">HashMap是否允许重复数据</td>
<td align="center">Key重复会覆盖，Value允许重复</td>
</tr>
<tr>
<td align="center">HashMap是否有序</td>
<td align="center">无序，指遍历HashMap的时候，得到元素的顺序基本不可能是put的顺序</td>
</tr>
<tr>
<td align="center">HashMap是否线程安全</td>
<td align="center">非线程安全</td>
</tr>
</tbody></table>
<h2 id="源码算法分析"><a href="#源码算法分析" class="headerlink" title="源码算法分析"></a>源码算法分析</h2><p>假设有这么一段代码代码：</p>
<pre><code class="java">    public static void main(String[] args)
    {
        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;111&quot;, &quot;111&quot;);
        map.put(&quot;222&quot;, &quot;222&quot;);
    }</code></pre>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li><p>无参初始化</p>
<pre><code class="java">    /**
     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity
     * (16) and the default load factor (0.75).
     */
    public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    }</code></pre>
<p>只初始化负载因此，默认为0.75，负载因子=预估容量/容量</p>
</li>
<li><p>带初始容量或负载因子的 参数的初始化</p>
<pre><code class="java">    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }</code></pre>
<p>初始化初始容量、负载因子、以及扩容阈值。</p>
<p>看下阈值的说明:</p>
<pre><code class="java">    /**
     * The next size value at which to resize (capacity * load factor).
     *
     * @serial
     */
    // (The javadoc description is true upon serialization.
    // Additionally, if the table array has not been allocated, this
    // field holds the initial array capacity, or zero signifying
    // DEFAULT_INITIAL_CAPACITY.)
    int threshold;</code></pre>
<p>当超过扩容阈值时，需要调用resize进行扩容(resize下面会介绍)。</p>
<p><strong>而阈值是如何计算出来的？</strong>这是JAVA 8的优化，看下tableSizeFor的代码：</p>
<pre><code class="java">    /**
     * Returns a power of two size for the given target capacity.
     */
    static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n &gt;&gt;&gt; 1;
        n |= n &gt;&gt;&gt; 2;
        n |= n &gt;&gt;&gt; 4;
        n |= n &gt;&gt;&gt; 8;
        n |= n &gt;&gt;&gt; 16;
        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
</code></pre>
<p>返回<strong>大于输入参数且最近的2的整数次幂的数</strong>，分析下怎么做到的：</p>
<p>比如输入10，n=9 二进制为1001(4位二进制）：</p>
<p><code>n |= n &gt;&gt;&gt; 1</code>  右移一位等于100，或运算=1101 </p>
<p><code>n |= n &gt;&gt;&gt; 2</code>   右移二位等于11，或运算=1111 </p>
<p>…</p>
<p>1111=15后续位移和或运算结果不变。相当于将当前位都置1（4个1）。最后n+1，即得到了2的整数次幂的值了。</p>
<p>再来看下<code>int n = cap - 1</code>再复制的目的是找到的目标值大于或<strong>等于</strong>原值。例如二进制1000，十进制为8。如果不对它减1而直接操作，得到答案16，显然不是结果。减1后二进制为111，再进行操作则会得到原来的数值1000，即8。这是为了解决当前输入值正好等于<strong>最近的2的整数次幂的数</strong>，</p>
</li>
</ul>
<p>  为什么需要位移1、2…16次，一共是30次，是因为容量最大是2的30次方。</p>
<p>  <code>MAXIMUM_CAPACITY</code>是2的30次方。</p>
<pre><code class="java">      /**
       * The maximum capacity, used if a higher value is implicitly specified
       * by either of the constructors with arguments.
       * MUST be a power of two &lt;= 1&lt;&lt;30.
       */
      static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code></pre>
<p>  这种找出阈值的方法非常高效，可见JAVA 8对容器优化了很多。</p>
<ul>
<li><p>参数为另外一个map的初始化</p>
<pre><code class="java">    /**
     * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the
     * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with
     * default load factor (0.75) and an initial capacity sufficient to
     * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.
     *
     * @param   m the map whose mappings are to be placed in this map
     * hrows  NullPointerException if the specified map is null
     */
    public HashMap(Map&lt;? extends K, ? extends V&gt; m) {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        putMapEntries(m, false);
    }

    /**
     * Implements Map.putAll and Map constructor
     *
     * @param m the map
     * @param evict false when initially constructing this map, else
     * true (relayed to method afterNodeInsertion).
     */
    final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) {
        int s = m.size();
        if (s &gt; 0) {
            if (table == null) { // pre-size
                float ft = ((float)s / loadFactor) + 1.0F;
                int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?
                         (int)ft : MAXIMUM_CAPACITY);
                if (t &gt; threshold)
                    threshold = tableSizeFor(t);
            }
            else if (s &gt; threshold)
                resize();
            for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {
                K key = e.getKey();
                V value = e.getValue();
                putVal(hash(key), key, value, false, evict);
            }
        }
    }
</code></pre>
<p>这段代码比较简单，这里面主要的操作<code>putVal(hash(key), key, value, false, evict);</code>在下面put的操作的时候阐述。</p>
</li>
</ul>
<h3 id="新增-修改操作"><a href="#新增-修改操作" class="headerlink" title="新增/修改操作"></a>新增/修改操作</h3><p>看下put方法的源码：</p>
<pre><code class="java">    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }</code></pre>
<p>就一个方法<code>putVal(hash(key), key, value, false, true);</code>，其源码如下：</p>
<pre><code class="java">    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; 
        if ((tab = table) == null || (n = tab.length) == 0) //(1)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) &amp; hash]) == null) //(2)
            tab[i] = newNode(hash, key, value, null);
        else { //(3)
            Node&lt;K,V&gt; e; K k;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) //(3.1)
                e = p;
            else if (p instanceof TreeNode)//(3.2)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else { //（3.3）
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key  (4)
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size &gt; threshold)
            resize(); //（4）
        afterNodeInsertion(evict);
        return null;
    }</code></pre>
<p>下面按照putValue操作按照操作流程的主题脉络和关键方法来阐述：</p>
<ol>
<li><p>(1) 如果链表数组table是空的，则调用resize初始化容量（可以理解为懒加载）。</p>
</li>
<li><p>(2) 如果插入的位置<code>tab[i = (n - 1) &amp; hash]</code>为空，就基于当前插入元素新建一个链表节点，保存到当前链表数组的位置。</p>
</li>
<li><p>(3) 如果插入的链表数组的位置已经有其他元素节点保存过了（p节点）.</p>
<ol>
<li><p>(3.1)如果当前位置的元素(hash和key相等)与将要插入的元素相等，则<code>e=p</code>。</p>
</li>
<li><p>(3.2)如果当前位置的元素节点p属于TreeNode，则进行树化插入。</p>
</li>
<li><p>(3.3)如果当前插入位置已存在的元素节点p与插入元素不相等，且非TreeNdoe节点。则已p节点为头节点进行链表的next操作遍历插入。</p>
<ul>
<li><p>如果遍历到达p链表的尾部（p.next是null）则插入元素。</p>
</li>
<li><p>如果链表长度（next的次数）超过或达到树化阈值TREEIFY_THRESHOLD - 1，则会树化<code>treeifyBin</code>（下面会讲）。</p>
</li>
<li><p>如果插入遍历next的时候发现节点与插入节点相等，则返回停止遍历。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>(4) 元素数量大于阈值<code>threshold</code>则调用<code>resize</code>扩容。</p>
</li>
</ol>
<p>扩容resize和树化操作<code>putTreeVal</code>下面会单独进行讲解。</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>删除元素有两个方法：</p>
<ol>
<li><p><code>remove(Object key)</code></p>
</li>
<li><p><code>remove(Object key, Object value)</code></p>
</li>
</ol>
<p>这两个方法都是调用的<code>removeNode(int hash, Object key, Object value,
                               boolean matchValue, boolean movable)</code>。其中value值是在删除的时候判断下</p>
<p>我们看下最常用的第一种删除方式的源码：</p>
<pre><code class="java">    public V remove(Object key) {
        Node&lt;K,V&gt; e;
        return (e = removeNode(hash(key), key, null, false, true)) == null ?
            null : e.value;
    }</code></pre>
<p>核心是调用removeNode方法，分析下它的代码：</p>
<pre><code class="java">    final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,
                               boolean matchValue, boolean movable) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;
        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
            (p = tab[index = (n - 1) &amp; hash]) != null) {
            Node&lt;K,V&gt; node = null, e; K k; V v;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                node = p; //(1)
            else if ((e = p.next) != null) {//(2)
                if (p instanceof TreeNode)
                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);//
                else {
                    do {
                        if (e.hash == hash &amp;&amp;
                            ((k = e.key) == key ||
                             (key != null &amp;&amp; key.equals(k)))) {
                            node = e;
                            break;
                        }
                        p = e;
                    } while ((e = e.next) != null);
                }
            }
            if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||
                                 (value != null &amp;&amp; value.equals(v)))) { //(3)
                if (node instanceof TreeNode)
                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);
                else if (node == p)
                    tab[index] = node.next;
                else
                    p.next = node.next;
                ++modCount;
                --size;
                afterNodeRemoval(node);
                return node;
            }
        }
        return null;
    }</code></pre>
<p>删除与新增操作算法类似，主要包含以下算法步骤其中：</p>
<ol>
<li>(1)按照hash计算出的索引index位置数组桶中存的链表头节点元素是否为当前删除元素。如果是记为<code>node</code>变量。</li>
<li>(2)头节点不是当前删除元素节点，且当前头节点链表下一个节点非空。<ol>
<li>头节点是数节点类型<code>TreeNode</code>，则<code>node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</code></li>
<li>如果否且链表下一个节点非空，则开始从当前索引位置的链表头节点开始往后遍历。</li>
</ol>
</li>
<li>找到了元素node，按照node的不同删除的情况分为：<ol>
<li>找到的节点node如果是TreeNode则按照<code>((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);</code>方式删除。</li>
<li>如果node是数组桶中的链表头节点p，则将node的得下一个节点覆盖到当前数组桶的index位置上。对</li>
<li>如果node不是数组桶的头元素，则将删除元素的上一个节点得next指针指向删除节点的next指针指向的节点，即将当前删除节点脱离链表。</li>
</ol>
</li>
</ol>
<p>总结删除、插入元素的算法还是比较简单的，下面来看下操作元素过程中用到的几个比较快件的算法。</p>
<p>扩容（resize）、树化操作、hash算法。</p>
<h3 id="扩容resize算法"><a href="#扩容resize算法" class="headerlink" title="扩容resize算法"></a>扩容resize算法</h3><p>先来看下resize的源码（阅读过程中的主干算法都用1.2.3等按步骤编号标识，其他注释不标注编号）：</p>
<pre><code class="java">    final Node&lt;K,V&gt;[] resize() {
        Node&lt;K,V&gt;[] oldTab = table;//当前所有元素所在数组，称为老的元素数组
        int oldCap = (oldTab == null) ? 0 : oldTab.length;//老元素的数组长度
        int oldThr = threshold;//老的扩容阈值设置
        int newCap, newThr = 0;//新数组的容量，新数组的扩容阈值都初始化为0
        if (oldCap &gt; 0) { //如果老数组长度大于0，说明已经存在元素
            if (oldCap &gt;= MAXIMUM_CAPACITY) {//如果数组元素个数大于等于限定的最大容量（2的30次方）
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            /*
            1.如果数组元素个数在正常范围内，那么新的数组容量为老的数组容量的2倍（左移1位）
            如果扩容之后的新容量小于最大容量 并且老的数组容量大于等于默认初始化容量，那么新数组的扩容阈值设置为老阈值的2倍。
            （老的数组容量大于16的初始化容量值，要么已经经历了至少一次扩容）
            */
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &lt;&lt; 1; // double threshold
        }
        //PS1:运行到这个else if，说明老数组没有任何元素
        //如果老数组的扩容阈值大于0，那么设置新数组的容量为该阈值
        //这一步也就意味着构造该map的时候，指定了初始化容量
        else if (oldThr &gt; 0) // initial capacity was placed in threshold
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults
            //如果能运行到这里，说明调用了无参构造函数初始化map，并且第一次添加元素
            newCap = DEFAULT_INITIAL_CAPACITY;//设置新数组容量为16
            //新数组扩容阈值为16*0.75=12。0.75位默认负载因子（当元素个数达到4分支3，那么扩容）
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
           //如果扩容阈值为0（PS1的情况），扩容后阈值=新的容量*负载因子
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;//设置map的扩容阈值为新的阈值
        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
        //创建新的数组（对于第一次添加元素，这个数组是第一个数组；
        //2.对于存在oldTab的情况，那么这个数组需要扩容到新数组
        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        table = newTab;//将该map的table属性指向到该新数组
        if (oldTab != null) {//3.如果老数组不为空，说明是扩容操作，涉及到元素的转移操作
            for (int j = 0; j &lt; oldCap; ++j) {//遍历老数组
                Node&lt;K,V&gt; e;
                if ((e = oldTab[j]) != null) {//如果当前位置不为空，需要转移元素
                    oldTab[j] = null;//释放老数组中药转移走的元素的引用
                    if (e.next == null)//3.1如果元素没有下一个节点，说明链表只有一个节点（不冲突)
                        newTab[e.hash &amp; (newCap - 1)] = e;//按照新的容量hash确定存储位置
                    else if (e instanceof TreeNode)//如果转移元素是树化节点，树化操作（省略，会另外开一篇文章单独讨论树化）
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        //3.2 如果原数组的链表节点有next节点，说明链表有多冲突有多个节点，确定要将链表中的所有节点重新计算放到新位置（跟着老链表走）还是扩容后放到新的数组中
                        Node&lt;K,V&gt; loHead = null, loTail = null;//理解为：低位头尾节点
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;//理解为：高位头尾节点
                        Node&lt;K,V&gt; next;
                        do {//这个循环就是在遍历数组中链表头节点开始遍历链表，下面会在文中详细解析该算法
                            next = e.next;
                            //如果遍历节点不需要转移位置，该元素放在低位链表中。
                            if ((e.hash &amp; oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {//如果遍历节点需要转移位置，该元素放在高位链表中
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);//3.2.1 将低位链表的头节点放到到新数组的原先的位置
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {//3.2.2 将高位链表的头节点放到新库容数组的高位位置j + oldCap
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }</code></pre>
<p>resize的流程主要分为三步：</p>
<ol>
<li><p>计算库容、及扩容后的阈等参数的调整（详细见代码注解）。扩容的参数调整主要分成几种情况</p>
<ul>
<li>数组中已经有元素存在，新增元素时进行扩容的参数调整。</li>
<li>数组中没有元素，使用初始化容量参数的构造函数初始化map。</li>
<li>数组中没有元素，使用无参的构造函数初始化map。</li>
</ul>
</li>
<li><p>需要new一个新扩容后的数组桶table出来。<strong>一般来说如果如果是有元素的数组库扩容，数组桶table得扩容是原先的2倍。</strong> 其他情况的扩容参数见1.中对应的代码注释。</p>
</li>
<li><p>旧桶的元素往扩容新桶中进行拷贝。</p>
<ul>
<li><p>3.1 如果同数组的链表节点没有next节点，说明这个链表只有一个节点（hash不冲突），那么就直接按照新的容量hash确定存储引用的位置。</p>
</li>
<li><p>3.2 如果原数组的链表节点有next节点，说明当前Hash位置有冲突，链表中有多个节点。需要将链表中的所有节点重新计算位置（把原链表的元素遍历，分别放到高低两个链表中，然后把高低位两个链表分别放到原位置和新增容量的位置中）。下面详细介绍下转移的算法：</p>
<ul>
<li><p>首先，需要判断原链表中的元素是放在老位置还是新位置：</p>
<p><code>(e.hash &amp; oldCap) == 0</code>   </p>
<p><strong>算法思想</strong>：数组的长度一定是2的N次方（例如16），<strong>如果hash值和该长度做与运算，结果为0，就说明该hash值和数组长度取模后的值一定小于数组长度（例如mod值为1）</strong>，<br> 该hash值再和新数组的长度取摸的话mod值也不会放生变化，所以该元素的在新数组的位置和在老数组的位置是相同的，所以该元素可以放置在低位链表中。反之元素放到高位得链表中。</p>
<p>注意：不是(e.hash &amp; (oldCap-1));而是(e.hash &amp; oldCap)，(e.hash &amp; oldCap) 得到的是元素的在数组中的位置是否需要移动。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="树化算法"><a href="#树化算法" class="headerlink" title="树化算法"></a>树化算法</h3><p>在增加、扩容、删除等操作上都会涉及树化节点的操作，树化操作篇幅较长，因此我会开一篇新的博客来总结介绍HashMap的树化操作。届时会把文章链接更新在此。</p>
<h3 id="hash算法及hash碰撞"><a href="#hash算法及hash碰撞" class="headerlink" title="hash算法及hash碰撞"></a>hash算法及hash碰撞</h3><p>注意到在桶数组（哈希表）中保存数据的位置通过：hash与数组长度-1与得到，</p>
<pre><code class="java">i = (n - 1) &amp; hash</code></pre>
<p>这里的hash值并不是key本身的hashcode，而是来自hashmap内部的一个方法得到：</p>
<pre><code class="java">    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    }</code></pre>
<p>举例hash的调用：</p>
<pre><code class="java">    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }</code></pre>
<p>JDK1.8的实现中，优化了高位运算的算法，将hashCode的高16位与hashCode进行异或运算，这是因为有些数据计算出的哈希值差异主要在高位，而 HashMap里的哈希寻址是忽略容量以上的高位的，那么这种处理就可以有效避免类似情况下的<strong>hash碰撞</strong>。注同一个hashcode计算出的hash值一定相等。</p>
<ul>
<li><p>解决hash冲突，有哪些典型的方法？</p>
<p>开发地址法、再哈希法、链地址法</p>
</li>
</ul>
<h3 id="hashcode、equals注意点"><a href="#hashcode、equals注意点" class="headerlink" title="hashcode、equals注意点"></a>hashcode、equals注意点</h3><ul>
<li>equals相等，hashcode一定要相等。<ul>
<li>如果equals相等、hashcode不相等，元素就会被存到不同的桶位置。</li>
<li>如果eqauls不相等、hashcode相等，元素虽然会保存同一个桶位置，但是在equals比较的时候发现不相等，会当做两个元素保存当前桶位置的链表中。这同样会导致重复元素被存储，链表变长，从而性能下降。</li>
</ul>
</li>
<li>重写了hashcode也要重写equals。</li>
<li>hashcode需要保持一致性，状态改变返回的哈希值仍然要一致。</li>
<li>equals的对称、反射、传递等特性。</li>
</ul>
<h2 id="使用场景选择"><a href="#使用场景选择" class="headerlink" title="使用场景选择"></a>使用场景选择</h2><p>一般来说没有顺序要求，都会选择HashMap，而与HashMap相似的还有Hashtable的键值对组合，他们的区别也往往在面试时经常被问到，下面来总结下两者区别，也能知道其使用场景：</p>
<ol>
<li>Hashtable是线程安全的，    Hashtable对外提供的方法都使用<code>synchronized</code>修饰，也就是同步的，而HashMap就是线程非安全的。</li>
<li>Hashtable不允许空的value，空的value将导致空指针异常，而HashMap则无所谓，没有这方面的限制，HashMap的key是null只允许存在一个，而value是null可以无数个。</li>
<li>HashMap的默认初始容量是16，Hashtable是11。</li>
<li>HashMap的hash值重新计算过，Hashtable直接使用hashCode。</li>
<li>HashMap继承自AbsractMap，Hashtable继承自Dictionary类。</li>
<li>两个容器的的rehash算法不同。</li>
</ol>
<h2 id="HashMap总结"><a href="#HashMap总结" class="headerlink" title="HashMap总结"></a>HashMap总结</h2><ol>
<li>HashMap底层是一个Node数组（Node&lt;K,V&gt; [] table），在数组的具体索引位置，如果存在多个节点（hash冲突），则可能是以链表或红黑树的形式存在。</li>
<li>增加、删除、查找键值对时，定位到哈希桶数组的是很关键的一步，通过3个操作来完成：1）拿到key的hashcode值；2）将hashcode的高位参与与或运算，重新计算hash值。3）将计算出来的hash值与（table.length-1）进行&amp;运算。</li>
<li>HashMap的初始容量（capacity）是16，capactiy必须是2的幂次方（如果不是会采用tableForSize算法取最接近大于等于当前初始化容量的2次幂的值）；默认负载因子load factor是0.75；实际能存放的节点个数（容量阈值）=capacity*load factor。</li>
<li>HashMap在触发扩容后，阈值会变成原来的2倍，并且会重新hash，重hash后的索引位置index的节点新分布位置最多只有2种情况：原索引位置或原索引位置+oldCap位置。例如capacity为16，索引位置5的节点扩容后，只可能分布在原索引位置5和索引位置（5+16）21。</li>
<li>导致HashMap扩容后，同一个索引位置的节点重hash最多分布在两个位置的根本原因是：1）table的长度始终为2的n次方；2）索引位置的计算方法“(table.length-1)&amp;hash”。HashMap扩容是一个比较耗时的操作，定义HashMap时尽量给个接近的初始容量值。</li>
<li>HashMap有threshold属性和loadFactor属性，但是没有capacity属性。初始化时，如果传了初始容量值，该值是会存为threshold变量，并且Node数组是在第一次put时才会进行初始化，初始化时会将此时的threshold值作为新表的capacity值，然后用capacity和loaderFactor计算新表的真正threshold值。</li>
<li>当同一个索引位置的节点在增加后达到9个时，会触发链表节点（Node）转成红黑树（TreeNode，间接继承Node），转成红黑树节点后，其实链表的结构还在，通过next属性维持。链表节点转红黑树节点的具体方法为源码treeifyBin(Node&lt;K,V&gt;[] tab, int hash)方法。</li>
<li>当同一个索引位置的节点在移除后到达6个时，并且该索引位置的节点为红黑树节点，会触发红黑树节点转链表节点。红黑树节点转链表节点的具体方法为untreeify(HashMap&lt;K,V&gt; map)方法。</li>
<li>HashMap在JDK1.8之后不再有死循环的问题，JDK1.8之前存在死循环的根本原因是在扩容后同一索引位置的节点顺序会反掉。</li>
<li>HashMap是非线程安全的，在并发场景下使用ConcurrentHashMap来代替。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/v123411739/article/details/78996181" target="_blank" rel="noopener">https://blog.csdn.net/v123411739/article/details/78996181</a><br><a href="https://www.cnblogs.com/xrq730/p/5030920.html" target="_blank" rel="noopener">https://www.cnblogs.com/xrq730/p/5030920.html</a></p>

    </div>

    
    
    
        <div class="reward-container">
  <div>如果乐意，请喝杯茶吧.</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/webchatpay.jpeg" alt="Zhou Lei 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpeg" alt="Zhou Lei 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/Collection/" rel="tag"># Collection</a>
              <a href="/tags/%E9%9B%86%E5%90%88/" rel="tag"># 集合</a>
              <a href="/tags/HashMap/" rel="tag"># HashMap</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/01/16/2019-1-16-java-collection-LinkedList/" rel="prev" title="【Java集合】-LinkedList">
      <i class="fa fa-chevron-left"></i> 【Java集合】-LinkedList
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/01/31/2019-2-1-java-collection-red-black-tree/" rel="next" title="【数据结构与算法】Java中Map用到的数据结构:红黑树">
      【数据结构与算法】Java中Map用到的数据结构:红黑树 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构"><span class="nav-number">2.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四个特性关注点"><span class="nav-number">3.</span> <span class="nav-text">四个特性关注点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码算法分析"><span class="nav-number">4.</span> <span class="nav-text">源码算法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化"><span class="nav-number">4.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新增-修改操作"><span class="nav-number">4.2.</span> <span class="nav-text">新增&#x2F;修改操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除元素"><span class="nav-number">4.3.</span> <span class="nav-text">删除元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扩容resize算法"><span class="nav-number">4.4.</span> <span class="nav-text">扩容resize算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#树化算法"><span class="nav-number">4.5.</span> <span class="nav-text">树化算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hash算法及hash碰撞"><span class="nav-number">4.6.</span> <span class="nav-text">hash算法及hash碰撞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashcode、equals注意点"><span class="nav-number">4.7.</span> <span class="nav-text">hashcode、equals注意点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用场景选择"><span class="nav-number">5.</span> <span class="nav-text">使用场景选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap总结"><span class="nav-number">6.</span> <span class="nav-text">HashMap总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhou Lei"
      src="/images/avatar2.png">
  <p class="site-author-name" itemprop="name">Zhou Lei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">58</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhoulei17" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhoulei17" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:tcals1@163.com" title="E-Mail → mailto:tcals1@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="/zhoulei.site" title="zhoulei.site">site</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhou Lei</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">221k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:21</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
