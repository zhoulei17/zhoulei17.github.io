
<!DOCTYPE html>
<html lang="en">


<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020"/>
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="java,并发,线程协作,信号量," />
  

  
    <meta name="description" content="【线程协作篇】三、信号量Semaphore-控制临界区资源的多线程访问" />
  
  
  
  <link rel="icon" type="image/x-icon" href="/images/footer-logo.png">
  
  <title>【线程协作篇】三、信号量Semaphore-控制临界区资源的多线程访问 [ Hexo ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    
    <span class="title" style="text-transform:none">Hexo</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            
              <li class="pure-menu-item"><a href="/" class="pure-menu-link">Home</a></li>
            
          
      
          
            
              <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
            
              <a href="#" id="post" class="pure-menu-link">文章</a>
              <ul class="pure-menu-children">
              
                  
                    <li class="pure-menu-item"><a href="/categories" style="color:#202020;" class="pure-menu-link">Categories</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="/archives" style="color:#202020;" class="pure-menu-link">Archives</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="/tags" style="color:#202020;" class="pure-menu-link">Tags</a></li>
                  
              
              </ul>
            </li>
          
      
          
            
              <li class="pure-menu-item"><a href="/paper" class="pure-menu-link">Papers</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/project" class="pure-menu-link">项目</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/activity" class="pure-menu-link">动态</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/search" class="pure-menu-link">Search</a></li>
            
          
      
  </ul>
   
</nav>

  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        【线程协作篇】三、信号量Semaphore-控制临界区资源的多线程访问
      </h1>
      <span>
        
        <time class="time" datetime="2019-07-05T16:00:00.000Z">
        2019-07-06
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/" rel="tag">信号量</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C/" rel="tag">线程协作</a></li></ul>
      </span>
    </span>
      <span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
      <span class="slash">/</span>
      <span class="read">阅读耗时 14 分钟</span>
    </header>

    <div class="post-content">
      <p>@[toc]</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Semaphore，又称为信号量，类似于现实生活中的信号灯，车辆能不能通行要看绿灯。同样，在编程世界里，线程能否运行，也要看信号量是不是允许。<strong>不同于concurrent.Lock或者内建的sychronized锁同一时刻最多只有一个线程访问临界区，Semaphore允许n个线程同时访问临界区。</strong></p>
<p>信号量由迪杰斯特拉于1965年提出，之后的15年，信号量一直都是并发编程领域的总结者，知道1980年管程被提出来，才有了第二选择。目前几乎所有的并发编程语言都支持信号量机制。</p>
<p>并发编程<a href="[https://zhoulei17.github.io/2019/05/09/java-concurreny-system-courrenency/#%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8Epv%E6%93%8D%E4%BD%9C](https://zhoulei17.github.io/2019/05/09/java-concurreny-system-courrenency/#信号量与pv操作)">操作系统层面讲过信号量</a>,下面就简单介绍下信号量模型，以此说明信号量实现的原理。</p>
<h1 id="信号量模型"><a href="#信号量模型" class="headerlink" title="信号量模型"></a>信号量模型</h1><p>信号量模型很简单，可以概括为：<strong>一个计数器，一个等待队列，三个方法</strong>。在信号量模型里，计数器和等待队列是对外透明的，所以只能通过三个方法：init()、down()、up()来说明。用图来表示:</p>
<p><img src="/img/in-post/image-20190709235323544.png" alt=""></p>
<p>在三个方法详细的语义如下：</p>
<ul>
<li>init()：设置计算器的初始值，即资源的初始数量。</li>
<li>down()：等同于P、V信号量的P操作，申请资源的操作，计算器减1；如果此时计算器的值小于0，则当前线程被阻塞，否则当前线程可以继续执行。</li>
<li>up()：等同于P、V信号量的V操作，释放资源，计算器加1；如果此时计数器的值小于或者等于0，则唤醒等待队列中的一个线程，并将其从等待队列中移除。</li>
</ul>
<p>这里init()、down()、up()三个方法都是原子性的，并且原子性是由信号量模型的实现方保证的。在Java中，信号量由<code>java.util.cocurrent.Semaphore</code>实现，Semaphore类能保证这三个方法都是原子操作(具体原子操作如何保证，以及这三个方法的实现原理待后续源码解析)。大致的代码模型如下：</p>
<pre><code class="java">class Semaphore{
  // 计数器
  int count;
  // 等待队列
  Queue queue;
  // 初始化操作
  Semaphore(int c){
    this.count=c;
  }
  // 
  void down(){
    this.count--;
    if(this.count&lt;0){
      // 将当前线程插入等待队列
      // 阻塞当前线程
    }
  }
  void up(){
    this.count++;
    if(this.count&lt;=0) {
      // 移除等待队列中的某个线程 T
      // 唤醒线程 T
    }
  }
}
</code></pre>
<p>down()、up()等同信号量中的P、V操作申请与释放资源，在Java Semaphore中等价于acquire()和release()方法。</p>
<h1 id="如何使用信号量"><a href="#如何使用信号量" class="headerlink" title="如何使用信号量"></a>如何使用信号量</h1><h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>信号量等同于过红绿灯，绿灯给行人发放通行许可。只不过互斥场景运行一名行人通过(进入临界区)，而信号量允许多名行人通过进入临界区。下面以count+=1累加操作说明，只允许一个线程执行，也就是说要保证互斥。那这种情况信号量是如何控制的？</p>
<pre><code class="java">static int count;
// 初始化信号量
static final Semaphore s 
    = new Semaphore(1);
// 用信号量保证互斥    
static void addOne() {
  s.acquire();
  try {
    count+=1;
  } finally {
    s.release();
  }
}
</code></pre>
<p>分析下，信号量是如何保证互斥的。假设两个线程T1、T2同时访问addOne()方法。</p>
<p>当它们同时调用acquire()的时候，由于acquire是一个原子操作，所以只能由一个线程(假设是T1)把信号量减为0，另外一个线程(T2)则将计数器减为-1。</p>
<p>对于线程T1，信号量里面的计数器的值是0，大于等于0，所以线程T1会继续执行；</p>
<p>对于线程T2，信号量里面的计数器的值是-1，小于0，按照信号量模型里对down()操作的描述，线程T2将被阻塞。</p>
<p>所以此时只有线程T1会进入临界区执行count+=1；</p>
<p>当线程T1执行release操作，也就是up()操作的时候，信号量里的计数器的值是-1，加上1之后的值是0，大于等于0，按照信号量模型up()操作的描述，此时等待队列T2将被唤醒。于是T2在T1执行完临界区代码之后获得进入临界区的执行的许可，<strong>从而保证了互斥性。</strong></p>
<h1 id="使用信号量实现限流器"><a href="#使用信号量实现限流器" class="headerlink" title="使用信号量实现限流器"></a>使用信号量实现限流器</h1><p>上面的例子，我们用信号量实现了一个最简单的互斥锁功能。实际上信号量不同于Lock的功能，不单单只有一个互斥功能，还有一个功能是Lock不容易实现的，那就是：<strong>Semaphore可以允许多个线程同时访问临界区</strong>。</p>
<p>下面通过一个例子演示，如何控制不多于N个线程同时进入临界区的场景。比如实现一个对象池的功能，一次性创建出N个对象，之后所有线程重复利用这N个对象，当然在对象释放前，也是不允许其他线程使用的(如果对象本身需要保证线程安全)。这里面对对象的访问需要进行限流，就是不允许多于N个线程同时进入临界区。</p>
<pre><code class="java">package thread.communication.semaphore;

import java.util.List;
import java.util.Vector;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;
import java.util.function.Function;

public class ObjectPool_Semaphore&lt;T,R&gt; {
    List&lt;T&gt; pool;
    //用信号量实现限流器
    final Semaphore sem;

    ObjectPool_Semaphore(int size,T t) {
        pool =  new Vector&lt;T&gt;();
        for (int i = 0 ; i &lt; size ; i ++) {
            Object obj = (Long)t + i;
            pool.add((T)obj);
        }
        sem = new Semaphore(size);
    }
    //利用对象池的对象，调用 func
    R exec(Function&lt;T,R&gt; func) throws InterruptedException {
        T t = null;
        sem.acquire();
        try {
            t = pool.remove(0);
            return func.apply(t);
        }finally {
            pool.add(t);
            sem.release();
        }
    }
    public static void main(String[] args) throws InterruptedException {
        //创建对象池
        final ObjectPool_Semaphore&lt;Long, String&gt; pool = new ObjectPool_Semaphore&lt;Long, String&gt;(15, 0L);
        Thread thread = new Thread(() -&gt;{
            try {
                for (int i = 0  ; i &lt; 10 ; i++) {
//                    Thread.sleep((long) (50*Math.random()));
                    pool.exec(t -&gt;  {
                        System.out.println(&quot;Thread ---&quot;+t);
                        return t.toString();
                    });
                }
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

        });
        ExecutorService exec = Executors.newCachedThreadPool();
        //通过4个线程，每个线程10次循环访问对象池 4*10次，也就是需要控制最多15个线程的进入临界区，对象池内有15个共享对象。
        exec.submit(thread);
        exec.submit(thread);
        exec.submit(thread);
        exec.submit(thread);
        exec.shutdown();
    }
}
</code></pre>
<p>注意这里面对象池的容器是用的Vector，因为在临界区内存在最多15个线程的并发，必须要对象容器是线程安全的容器才能保证安全不出错。</p>
<p>输出：</p>
<pre><code class="java">Launched all tasks
Waiting Task now WaitingTask 1  
Waiting Task now WaitingTask 7  
Waiting Task now WaitingTask 0  
Waiting Task now WaitingTask 4  
Waiting Task now WaitingTask 2  
Waiting Task now WaitingTask 5  
Waiting Task now WaitingTask 8  
Waiting Task now WaitingTask 6  
Waiting Task now WaitingTask 3  
43 completed
Waiting Task now WaitingTask 9  
99 completed
36 completed
95 completed
94 completed
11 completed
21 completed
77 completed
7  completed
9  completed
75 completed
79 completed
10 completed
40 completed
96 completed
63 completed
23 completed
34 completed
29 completed
38 completed
55 completed
90 completed
88 completed
28 completed
5  completed
50 completed
8  completed
1  completed
12 completed
27 completed
98 completed
13 completed
72 completed
71 completed
2  completed
45 completed
91 completed
14 completed
31 completed
17 completed
6  completed
97 completed
35 completed
69 completed
20 completed
32 completed
4  completed
68 completed
37 completed
47 completed
87 completed
70 completed
84 completed
86 completed
66 completed
54 completed
42 completed
41 completed
46 completed
74 completed
57 completed
65 completed
0  completed
80 completed
19 completed
60 completed
15 completed
89 completed
51 completed
25 completed
53 completed
62 completed
58 completed
92 completed
76 completed
22 completed
56 completed
18 completed
85 completed
61 completed
30 completed
59 completed
67 completed
26 completed
24 completed
48 completed
39 completed
33 completed
3  completed
52 completed
93 completed
81 completed
78 completed
73 completed
44 completed
82 completed
49 completed
64 completed
83 completed
16 completed
Latch barrier passed for WaitingTask 1  
Latch barrier passed for WaitingTask 7  
Latch barrier passed for WaitingTask 4  
Latch barrier passed for WaitingTask 2  
Latch barrier passed for WaitingTask 0  
Latch barrier passed for WaitingTask 5  
Latch barrier passed for WaitingTask 8  
Latch barrier passed for WaitingTask 6  
Latch barrier passed for WaitingTask 3  
Latch barrier passed for WaitingTask 9  </code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在Java并发领域中，重点支持的还是管程模型：</p>
<p>引用网友不错的理解，来帮助理解信号量与管程的区别：</p>
<blockquote>
<p><img src="/img/in-post/image-20190710003048917.png" alt=""></p>
</blockquote>
<p>后续，还有Semaphore是如何实现acquire与release的，内部阻塞队列是如何做的？都使用了那些技巧？单独实现互斥与Lock的不同于优劣？敬请期待后面的详细的源码分析。</p>

    </div>

  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">Posts</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#背景"><span class="toc-text">背景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#信号量模型"><span class="toc-text">信号量模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#如何使用信号量"><span class="toc-text">如何使用信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#简单示例"><span class="toc-text">简单示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用信号量实现限流器"><span class="toc-text">使用信号量实现限流器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
  </div>


  </div>
</div>
<div class="copyright">
    <span>本作品采用</span>
    <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>


  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2019/07/04/2019-7-04-java-concurrency-communication-queue/" rel="next" title="【线程协作篇】二、生产者与消费者与阻塞队列">
          【线程协作篇】二、生产者与消费者与阻塞队列
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/2019/07/15/2019-7-15-java-concurrency-communication-CountDownLatch-CyclicBarrier/" rel="prev" title="【线程协作篇】四、CountDownLatch和CyclicBarrier：如何让多线程步调一致">
            【线程协作篇】四、CountDownLatch和CyclicBarrier：如何让多线程步调一致
          </a>
          <span>〉</span>
        
      </div>
    </div>
  

    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <div id="gitalk-container"></div>
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script type="text/javascript">
        var gitalk = new Gitalk({
            clientID: 'xxx',
            clientSecret: 'xxx',
            id: window.location.pathname,
            repo: 'issue repo name',
            owner: 'Github username',
            admin: 'github username'
        })
        gitalk.render('gitalk-container')
    </script>



    </div>

    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" href="https://github.com/fooying" target="_blank">GitHub</a> |
        <a class="bottom-item" href="/links">友情链接</a> |
        <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> |
        <a class="bottom-item" href="https://github.com/fooying/hexo-theme-xoxo-plus" target="_blank">Theme xoxo-plus</a> |
        <a class="bottom-item" href="/atom.xml">RSS</a>
    </div>
</footer>

  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



  
<script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
</script>


</body>
</html>
