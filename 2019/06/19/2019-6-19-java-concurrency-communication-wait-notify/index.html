
<!DOCTYPE html>
<html lang="en">


<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020"/>
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="java,并发,线程协作,wait," />
  

  
    <meta name="description" content="【线程协作篇】一、wait、notify、notifyAll&amp;Lock、Condition" />
  
  
  
  <link rel="icon" type="image/x-icon" href="/images/footer-logo.png">
  
  <title>【线程协作篇】一、wait、notify、notifyAll&amp;Lock、Condition [ Hexo ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    
    <span class="title" style="text-transform:none">Hexo</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            
              <li class="pure-menu-item"><a href="/" class="pure-menu-link">Home</a></li>
            
          
      
          
            
              <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
            
              <a href="#" id="post" class="pure-menu-link">文章</a>
              <ul class="pure-menu-children">
              
                  
                    <li class="pure-menu-item"><a href="/categories" style="color:#202020;" class="pure-menu-link">Categories</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="/archives" style="color:#202020;" class="pure-menu-link">Archives</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="/tags" style="color:#202020;" class="pure-menu-link">Tags</a></li>
                  
              
              </ul>
            </li>
          
      
          
            
              <li class="pure-menu-item"><a href="/paper" class="pure-menu-link">Papers</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/project" class="pure-menu-link">项目</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/activity" class="pure-menu-link">动态</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/search" class="pure-menu-link">Search</a></li>
            
          
      
  </ul>
   
</nav>

  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        【线程协作篇】一、wait、notify、notifyAll&amp;Lock、Condition
      </h1>
      <span>
        
        <time class="time" datetime="2019-06-18T16:00:00.000Z">
        2019-06-19
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/wait/" rel="tag">wait</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C/" rel="tag">线程协作</a></li></ul>
      </span>
    </span>
      <span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
      <span class="slash">/</span>
      <span class="read">阅读耗时 18 分钟</span>
    </header>

    <div class="post-content">
      <p>@[toc]<br>当使用线程运行多个任务时，可以通过锁（互斥）来同步两个任务的行为，从而使得一个任务不会干涉另一个任务的资源。两个任务在交替着访问某项共享资源(通常是内存)，可以使用互斥来使得任何时刻只有一个线程访问这项资源。</p>
<p>那么如何使任何彼此之间可以协作，以使得多个任务一起工作解决特定的问题，即解决的问题不是彼此之间的干涉，而是彼此之间的协作，因为在这类问题中，有一部任务必须在其他部分被解决之前解决。比如工程规划问题：必须先挖房子的地基，但是接下来可以并行地铺设钢结构和构建水泥部件，而这两项任务必须在混凝土浇筑之前完成。</p>
<p>任务协作，关键问题是任务之间的握手。为了实现握手，我们使用了<strong>相同的基础特征</strong>：互斥。在这种情况下，互斥能够确保只有一个任务可以响应某个信号，这样就可以根除任何可能的竞争条件。<strong>在互斥之上</strong>，我们为任何添加了一种途径，可以将其挂起，直到某些外部条件发生变化(例如，管道现在已经到位)，表示是时候让这个任务开动了。</p>
<p>这种握手，可以通过<strong>Object的方法wait和notify来安全地实现。JAVA SE5的并发类库还提供了具有await()和signal()方法的Condition对象</strong>。</p>
<h1 id="wait-与notifyAll-介绍"><a href="#wait-与notifyAll-介绍" class="headerlink" title="wait()与notifyAll()介绍"></a>wait()与notifyAll()介绍</h1><p>wait()会在等待外部条件发生变化的时候将任务挂起，并且只有在notify()和notifyAll()发生时，即表示发生了某些感兴趣的事物，这个任务才会被唤醒并去检查所发生的变化。因此，wait()提供了一种在任务之间对活动同步的方式。</p>
<p><strong>调用sleep()的时候锁并不会被释放，yield()也是如此；</strong></p>
<p>另外，当一个任务在方法中遇到wait()的调用的时候，线程的执行被挂起，对象上的锁被释放。正是因为wait()会释放锁，另外一个任务可以获得这个锁，因此在该对象中的其他sychronized方法可以在wait期间被调用。这一点至关重要，因为正是由于其他线程进入其他方法触发出使被挂起任务重新唤醒的状态变化。</p>
<h2 id="wait-与sleep-的不同点"><a href="#wait-与sleep-的不同点" class="headerlink" title="wait()与sleep()的不同点"></a>wait()与sleep()的不同点</h2><p>有两种形式的wait: </p>
<ul>
<li>第一种是带超时参数（毫秒）：</li>
</ul>
<ol>
<li>在wait期间对象锁是释放的。</li>
<li>可以通过notify、notifyAll或者另时间到期，从wait()中恢复。</li>
</ol>
<ul>
<li>第二种是不带参数的wait()。：</li>
</ul>
<p>这种wait()将无线等待下去，直到线程接收到notify()或者notifyAll的消息。</p>
<h2 id="注意是Object的wait、notify与notifAll"><a href="#注意是Object的wait、notify与notifAll" class="headerlink" title="注意是Object的wait、notify与notifAll"></a>注意是Object的wait、notify与notifAll</h2><p>wait()、notify以及notifyAll有一个比较特殊的方面，那就是这些方法是基于Object的一部分，而不是属于Thread的一部分。尽管开始看起来有点奇怪——仅仅针对线程的功能却作为通用基类的一部分而实现，不过这是有道理的，因为这些方法操作的锁也是所有对象的一部分。所以把wait放进任何同步控制方法中，而不用考虑这个类是继承自Thread还是实现了Runnable接口。<strong>实际上，只能在同步控制方法或同步块里调用wait、notify和notifyAll。</strong>(因为不用操作锁，所以sleep可以在非同步控制方法里调用)。</p>
<p>如果在非同步控制方法里调用这些方法，程序可以编译，但运行会报IllegalMonitorStateException异常，并伴随着一些含糊的消息，比如”当前线程不是所有者”，意思是，调用wait、notify和notifyAll的任务在调用这些方法时必须<strong>“拥有”</strong>对象的锁。</p>
<ul>
<li>对于使用sychronized修饰的同步方法，该类默认this就是同步监视器对象，因此可以在方法内直接调用者三个方法。</li>
<li>对于sychronized同步代码块，同步监视器是sychronzied括号内指定的对象，因此需要在指定的这个对象上调用这三个方法。</li>
</ul>
<h1 id="wait、notify、notifyAll的使用示例"><a href="#wait、notify、notifyAll的使用示例" class="headerlink" title="wait、notify、notifyAll的使用示例"></a>wait、notify、notifyAll的使用示例</h1><p>下面以Java编程思想中的 汽车打蜡示例来说明wait notify notifyAll的使用：</p>
<p>示例说明：两项任务，抛光和打蜡；</p>
<p>抛光任务在涂腊之前完成不能工作，而涂腊任务在涂另一层醋之前，必须等待抛光任务完成。</p>
<ul>
<li>共享对象为Car，打蜡抛光任务共同作用于Car：</li>
</ul>
<pre><code class="java">public class Car {

    private boolean waxOn = false;

    public synchronized void waxed() {
        waxOn = true;
        notifyAll();
    }

    public synchronized void buffed() {
        waxOn = false;
        notifyAll();
    }

    public synchronized void waitingForWaxing() throws InterruptedException {
        while(waxOn == false) {
            wait();
        }
    }

    public synchronized void waitingForBuffing() throws InterruptedException {
        while(waxOn == true) {
            wait();
        }
    }
}</code></pre>
<ul>
<li><p>抛光任务：</p>
<pre><code class="java">public class WaxOff implements Runnable {
    private Car car;
    public WaxOff(Car car) {
        this.car = car;
    }

    @Override
    public void run() {
        // TODO Auto-generated method stub
        while(!Thread.interrupted()) {
            try {
                car.waitingForWaxing();
                System.out.println(&quot;Wax off!&quot;);
                TimeUnit.MILLISECONDS.sleep(200);
                car.buffed();
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                System.out.println(&quot;Exiting via interrupt&quot;);
                Thread.currentThread().interrupt();//JVM异常处理会清除标志位，因此加入sleep被中断就会进入异常分支，就需要再次中断。
            }
        }
        System.out.println(&quot;Ending wax off txask&quot;);
    }

}</code></pre>
</li>
</ul>
<ul>
<li><p>打蜡任务：</p>
<pre><code class="java">public class WaxOn implements Runnable {
    private Car car;

    public WaxOn(Car car) {
        this.car = car;
    }
    @Override
    public void run() {
        while(!Thread.interrupted()) {
            try {
                System.out.println(&quot;Wax on!&quot;);
                TimeUnit.MILLISECONDS.sleep(200);
                car.waxed();
                car.waitingForBuffing();
            } catch (InterruptedException e) {
                System.out.println(&quot;Exiting via interrupt&quot;);
                Thread.currentThread().interrupt();
            }
        }
        System.out.println(&quot;Ending wax on task&quot;);
    }
}</code></pre>
</li>
</ul>
<ul>
<li><p>main函数：</p>
<pre><code class="java">public class WaxOMatic {

    public static void main(String[] args) throws InterruptedException {
        Car car = new Car();
        ExecutorService exec = Executors.newCachedThreadPool();
        exec.execute(new WaxOff(car));
        exec.execute(new WaxOn(car));
        TimeUnit.SECONDS.sleep(5);
        exec.shutdownNow();
    }    
}</code></pre>
</li>
</ul>
<p>输出：</p>
<pre><code class="java">Wax on!
Wax off!
Wax on!
Wax off!
Wax on!
Wax off!
Wax on!
Wax off!
Wax on!
Wax off!
Wax on!
Wax off!
Wax on!
Wax off!
Wax on!
Wax off!
Wax on!
Wax off!
Wax on!
Wax off!
Wax on!
Wax off!
Wax on!
Wax off!
Wax on!
Exiting via interrupt
Ending wax off txask
Exiting via interrupt
Ending wax on task</code></pre>
<h1 id="notify-与notifyAll的区别"><a href="#notify-与notifyAll的区别" class="headerlink" title="notify()与notifyAll的区别"></a>notify()与notifyAll的区别</h1><p>在开发过程中，可能会有多个任务在单个Car对象上处于wait状态，因此调用notifiYAll()比只调用notify要更安全。但是如果只有两个任务的协作，即只有一个任务会处于wait状态，选择notifyAll和notifyAll就无所谓了。</p>
<p>使用notifyAll而不是notify算是一种优化。</p>
<ul>
<li>使用notify时，在众多等待同一个锁的任务中只会有一个被唤醒。因此<ul>
<li>如果使用notify，就必须确保被唤醒的是恰当的任务。</li>
<li>另外，为了使用notify，所有任务必须等待相同的条件，因为如果你有多个任务在等待不同的条件，那么你就没办法确定唤醒的是不是恰当的任务。</li>
</ul>
</li>
<li>使用notifyAll，那么所有在这个同步监视器（锁）上等待的任务都会被唤醒。</li>
</ul>
<h1 id="错失的信号"><a href="#错失的信号" class="headerlink" title="错失的信号"></a>错失的信号</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当两个线程使用notify/wait或notifyAll/wait进行协作时，有可能由于错误的加锁位置而错过信号。假设线程T1通知T2，下面的实现方式就是有这个问题的：</p>
<pre><code class="java">T1:
sychronized(sharedMonitor) {
  &lt;设置T2的条件&gt;
  sharedMonitor.notify();
}

T2:
while(someCondition) {
  //ponit 1
  sychronized(sharedMonitor) {
    sharedMoniotr.wait();
  }
}</code></pre>
<p>&lt;设置T2的条件&gt;设置someCondition=fale，告诉T2不用调用wait。</p>
<p>假设T2执行判断发现someConidition==true。在Point1处，线程调度器可能已经切换到T1（即还没来得及wait）。而T1又改变someCondition=false，然后就调用notify。</p>
<p>当线程又重新切换至T2时，此时T2从Ponit1继续执行，盲目了执行wait挂起T2线程（而实际上状态条件已经被T1改变了，即somecondition=false，即T2不应该调用wait），<strong>那么此时T1刚刚发出的notify()就错失掉了</strong>。而T2也将无限地等待这个已经发送过的信号（即发生了notify,wait控制的错乱），此时产生了<strong>死锁</strong>。</p>
<p>说明T2的wait操作依赖T1和T2共享的someCondition，是一个竞态条件，</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h2><p>该问题的解放方案就是防止在someCondition变量上产生竞态条件。下面是T2正确的执行方式：</p>
<pre><code class="java">sychronized(sharedMonitor) {
  while(someConidition) {
    sharedMonitor.wait();
  }
}</code></pre>
<p>现在，如果T1首先执行，当控制返回T2时，T2将发现条件发生了变化，从而不会进入wait()。</p>
<p>反过来，如果T2首先执行，那它将进入wait()，并且稍后会由T1唤醒。因此，信号不会丢失了。</p>
<h1 id="使用wait、notify实现生产者与消费者"><a href="#使用wait、notify实现生产者与消费者" class="headerlink" title="使用wait、notify实现生产者与消费者"></a>使用wait、notify实现生产者与消费者</h1><p>wait、notify还经常用于实现生产者和消费者类应用场景。</p>
<ul>
<li>类：一个饭店(Restaurant)，它有一个厨师(Chef)和一个服务员(WaitPerson)。</li>
<li>逻辑：服务员必须等待厨师准备好膳食，当厨师准备好膳食通知服务员，之后服务员上菜，然后继续等待。厨师代表生产者，服务员代表消费者。两个任务必须在膳食被生产和消费时进行握手，而系统必须以有序的方式关闭。</li>
</ul>
<ul>
<li>饭店：<pre><code class="java">package thread.communication.producerconsumer;
</code></pre>
</li>
</ul>
<p>import java.util.concurrent.ExecutorService;<br>import java.util.concurrent.Executors;<br>import java.util.concurrent.TimeUnit;</p>
<p>public class Restaurant {<br>    Meal meal;<br>    ExecutorService exec = Executors.newCachedThreadPool();<br>    WaitPerson waitPerson = new WaitPerson(this);<br>    Chef chef = new Chef(this);</p>
<pre><code>public Restaurant() {
    exec.execute(chef);
    exec.execute(waitPerson);
}

public static void main(String[] args) {
    new Restaurant();
}</code></pre><p>}<br>class Meal {<br>    private final int orderNum;</p>
<pre><code>public Meal(int orderNum) {
    this.orderNum = orderNum;
}

@Override
public String toString() {
    return &quot;Meal [orderNum=&quot; + orderNum + &quot;]&quot;;
}</code></pre><p>}</p>
<pre><code>* 服务员：
```java
class WaitPerson implements Runnable {

    private Restaurant restaurant;

    public WaitPerson(Restaurant restaurant) {
        this.restaurant = restaurant;
    }

    @Override
    public void run() {
        try {
            while (!Thread.interrupted()) {
                synchronized (this) {
                    while (restaurant.meal == null) {
                        wait();
                    }
                }
                System.out.println(&quot;Waitperson got &quot; + restaurant.meal);
                synchronized (restaurant.chef) {
                    restaurant.meal = null;
                    restaurant.chef.notifyAll();
                }
            }
        } catch (InterruptedException e) {
            System.out.println(&quot;WaitPerson interrupted&quot;);
        }
    }
}</code></pre><ul>
<li>厨师：</li>
</ul>
<pre><code class="java">class Chef implements Runnable {
    private Restaurant restaurant;
    private int count = 0;

    public Chef(Restaurant r) {
        restaurant = r;
    }

    public void run() {
        try {
            while (!Thread.interrupted()) {
                synchronized (this) {
                    while (restaurant.meal != null) {
                        wait();
                    }
                }
                if (++count == 10) {
                    System.out.println(&quot;Out of food,closing&quot;);
                    restaurant.exec.shutdownNow();
                }
                System.out.print(&quot;Order up! &quot;);
                synchronized (restaurant.waitPerson) {
                    restaurant.meal = new Meal(count);
                    restaurant.waitPerson.notifyAll();
                }
                TimeUnit.MILLISECONDS.sleep(100);
            }
        } catch (InterruptedException e) {

            System.out.println(&quot;Chef interrupted&quot;);
        }

    }
}
</code></pre>
<p>输出：</p>
<p><img src="/img/in-post/image-20190703232317885.png" alt=""></p>
<p>后续篇，在总结队列时，还会介绍再用队列来实现生产者消费者场景的应用。</p>
<h1 id="使用显式的Lock和Condition对象"><a href="#使用显式的Lock和Condition对象" class="headerlink" title="使用显式的Lock和Condition对象"></a>使用显式的Lock和Condition对象</h1><p>使用互斥并允许挂起的基本类是<strong><code>Condition</code></strong>，可以通过在<code>Conditio</code>上调用<strong><code>await()</code></strong>来挂起一个任务。当外部条件发生变化时，以为着某个任务应该继续执行，可以通过调用<strong><code>signal()</code></strong>来通知这个任务，从而唤醒一个任务，或者调用singalAll来唤醒所有这个Condition上被其他自身挂起的任务(与使用notifyAll相比，signalAll是更安全的方式)。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>Wait、notify、notifyAll是Object的方法，且wait调用只阻塞和唤醒线程，阻塞时不持有锁。</li>
<li>Wait、notify、notifyAll要在锁内（互斥）调用，且锁的监视器对象为当前wait、notifyAll阻塞唤醒的对象。如上面的厨师和服务员的例子可以看到加锁的监视器对象可以看出。</li>
<li>注意notify和notifAll的区别。</li>
<li>注意加锁的范围，防止错失信号的发生。</li>
</ol>

    </div>

  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">Posts</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#wait-与notifyAll-介绍"><span class="toc-text">wait()与notifyAll()介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#wait-与sleep-的不同点"><span class="toc-text">wait()与sleep()的不同点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注意是Object的wait、notify与notifAll"><span class="toc-text">注意是Object的wait、notify与notifAll</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#wait、notify、notifyAll的使用示例"><span class="toc-text">wait、notify、notifyAll的使用示例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#notify-与notifyAll的区别"><span class="toc-text">notify()与notifyAll的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#错失的信号"><span class="toc-text">错失的信号</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#问题"><span class="toc-text">问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解决方案"><span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用wait、notify实现生产者与消费者"><span class="toc-text">使用wait、notify实现生产者与消费者</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用显式的Lock和Condition对象"><span class="toc-text">使用显式的Lock和Condition对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
  </div>


  </div>
</div>
<div class="copyright">
    <span>本作品采用</span>
    <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>


  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2019/05/15/2019-5-15-java-concurreny-java-thread-status/" rel="next" title="【基本概念篇】十一、Java线程的状态和生命周期">
          【基本概念篇】十一、Java线程的状态和生命周期
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/2019/07/04/2019-7-04-java-concurrency-communication-queue/" rel="prev" title="【线程协作篇】二、生产者与消费者与阻塞队列">
            【线程协作篇】二、生产者与消费者与阻塞队列
          </a>
          <span>〉</span>
        
      </div>
    </div>
  

    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <div id="gitalk-container"></div>
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script type="text/javascript">
        var gitalk = new Gitalk({
            clientID: 'xxx',
            clientSecret: 'xxx',
            id: window.location.pathname,
            repo: 'issue repo name',
            owner: 'Github username',
            admin: 'github username'
        })
        gitalk.render('gitalk-container')
    </script>



    </div>

    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" href="https://github.com/fooying" target="_blank">GitHub</a> |
        <a class="bottom-item" href="/links">友情链接</a> |
        <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> |
        <a class="bottom-item" href="https://github.com/fooying/hexo-theme-xoxo-plus" target="_blank">Theme xoxo-plus</a> |
        <a class="bottom-item" href="/atom.xml">RSS</a>
    </div>
</footer>

  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



  
<script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
</script>


</body>
</html>
