
<!DOCTYPE html>
<html lang="en">


<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020"/>
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="java,并发容器,ConcurrentHashMap," />
  

  
    <meta name="description" content="【并发容器和框架】一、CocurrentHashMap的实现原理与使用" />
  
  
  
  <link rel="icon" type="image/x-icon" href="/images/footer-logo.png">
  
  <title>【并发容器和框架】一、CocurrentHashMap的实现原理与使用 [ Hexo ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    
    <span class="title" style="text-transform:none">Hexo</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            
              <li class="pure-menu-item"><a href="/" class="pure-menu-link">Home</a></li>
            
          
      
          
            
              <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
            
              <a href="#" id="post" class="pure-menu-link">文章</a>
              <ul class="pure-menu-children">
              
                  
                    <li class="pure-menu-item"><a href="/categories" style="color:#202020;" class="pure-menu-link">Categories</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="/archives" style="color:#202020;" class="pure-menu-link">Archives</a></li>
                  
              
                  
                    <li class="pure-menu-item"><a href="/tags" style="color:#202020;" class="pure-menu-link">Tags</a></li>
                  
              
              </ul>
            </li>
          
      
          
            
              <li class="pure-menu-item"><a href="/paper" class="pure-menu-link">Papers</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/project" class="pure-menu-link">项目</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/activity" class="pure-menu-link">动态</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/search" class="pure-menu-link">Search</a></li>
            
          
      
  </ul>
   
</nav>

  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        【并发容器和框架】一、CocurrentHashMap的实现原理与使用
      </h1>
      <span>
        
        <time class="time" datetime="2019-10-26T16:00:00.000Z">
        2019-10-27
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ConcurrentHashMap/" rel="tag">ConcurrentHashMap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/" rel="tag">并发容器</a></li></ul>
      </span>
    </span>
      <span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
      <span class="slash">/</span>
      <span class="read">阅读耗时 24 分钟</span>
    </header>

    <div class="post-content">
      <p>@[toc]</p>
<h1 id="为什么引入ConcurrentHashMap"><a href="#为什么引入ConcurrentHashMap" class="headerlink" title="为什么引入ConcurrentHashMap"></a>为什么引入ConcurrentHashMap</h1><p>在并发编程中使用HashMap可能导致程序死循环。而使用线程安全的HashTable效率又非常低下，基于以上两个原因，便有了ConcurrentHash的出现。</p>
<ul>
<li><p>线程不安全的HashMap</p>
<p>在多线程环境下，使用HashMap进行put操作会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。</p>
</li>
<li><p>效率低下的的HashTable</p>
<p>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。</p>
</li>
<li><p>ConcurrentHashMap的锁分段技术可有效提升并发率</p>
<p>HashTable在高并发下的效率低下的原因是因为所有访问HashTable的线程必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争。</p>
<p>存储数据时分成一段段存储，每一段分配一把锁，这样当一个线程访问其中一个段数据时，其他段数据依然可以被其他线程访问。</p>
</li>
</ul>
<p>  分段锁是JDK1.7及其之前的实现技术，JDK1.8并没有使用分段锁技术。</p>
<h1 id="JDK-1-7的ConcurrentHashMap"><a href="#JDK-1-7的ConcurrentHashMap" class="headerlink" title="JDK 1.7的ConcurrentHashMap"></a>JDK 1.7的ConcurrentHashMap</h1><p>ConcurrentHashMap的设计一直在演进中，JDK 1.7和JDK 1.8的ConcurrentHashMap实现存在巨大的差异，公司现在使用的是JDK 1.8，因此我们着重分析JDK 1.8，在此之前1.7也先介绍下。</p>
<h2 id="JDK-1-7的ConcurrentHashMap的结构"><a href="#JDK-1-7的ConcurrentHashMap的结构" class="headerlink" title="JDK 1.7的ConcurrentHashMap的结构"></a>JDK 1.7的ConcurrentHashMap的结构</h2><p>主要结构由：</p>
<ul>
<li>分离锁 <strong>Segment</strong>、Segment内部集成一个<strong>HashEntry</strong>的数组。<ul>
<li>Segment是一种可重入锁，一个ConcurrentHashMap包含一个Segment数组，一个Segment包含一个HashEntry数组。Segment的结构与HashMap类似是一种数组和链表的结构。</li>
<li>每个HashEntry是一个链表结构的元素。</li>
</ul>
</li>
<li>HashEntry内部使用volatile的value字段来保证可见性，也利用了不可变对象的机制以改进利用Unsafe提供的底层能力，比如volatile access，直接完成部分操作，以优化性能，毕竟Unsafe中的很多操作是JVM intrinsic优化过的。</li>
</ul>
<p><img src="/img/in-post/image-20191030234301439.png" alt=""></p>
<h2 id="JDK-1-7-ConcurrentHashMap初始化"><a href="#JDK-1-7-ConcurrentHashMap初始化" class="headerlink" title="JDK 1.7 ConcurrentHashMap初始化"></a>JDK 1.7 ConcurrentHashMap初始化</h2><h3 id="1-初始化segment数组"><a href="#1-初始化segment数组" class="headerlink" title="1. 初始化segment数组"></a>1. 初始化segment数组</h3><p>先看源码：</p>
<pre><code class="java">    public ConcurrentHashMap(int initialCapacity,
                             float loadFactor, int concurrencyLevel) {
        if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)
            throw new IllegalArgumentException();
        if (concurrencyLevel &gt; MAX_SEGMENTS)
            concurrencyLevel = MAX_SEGMENTS;
        // Find power-of-two sizes best matching arguments
        int sshift = 0;
        int ssize = 1;
        while (ssize &lt; concurrencyLevel) {
            ++sshift;
            ssize &lt;&lt;= 1;
        }
        this.segmentShift = 32 - sshift;
        this.segmentMask = ssize - 1;
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        int c = initialCapacity / ssize;
        if (c * ssize &lt; initialCapacity)
            ++c;
        int cap = MIN_SEGMENT_TABLE_CAPACITY;
        while (cap &lt; c)
            cap &lt;&lt;= 1;
        // create segments and segments[0]
        Segment&lt;K,V&gt; s0 =
            new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),
                             (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);
        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];
        UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
        this.segments = ss;
    }</code></pre>
<p>Segments的长度ssize由concurrencyLevel计算得到。为了能通过按位与的散列算法来定位segment数组的索引，必须保证segments数组的长度是2的N次方，所以必须计算出一个大于等于concurrencyLevel的最小的2的N次方值作为segments的长度。假如concurrencyLevel等于14、15或16，ssize都会等于16，即容器里锁的个数也是16。</p>
<h3 id="2-初始化segmentShift和segmentMask"><a href="#2-初始化segmentShift和segmentMask" class="headerlink" title="2. 初始化segmentShift和segmentMask"></a>2. 初始化segmentShift和segmentMask</h3><p>这两个全局变量是用来定位segment的散列算法里使用的，sshift等于ssize从1向左移位的次数。concurrencyLevel默认等于16，所以sshift等于4。</p>
<ul>
<li>segmentShift用与定位参与散列运算的位数，segmentShift等于32减sshift，所以等于28（之所以是32是因为hash()的最大输出是32）。</li>
<li>segmentMask是散列运算的掩码，等于ssize减1，即15，掩码的二进制各位都是1.因为ssize的最大值都是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。</li>
</ul>
<h3 id="3-初始化每个segment"><a href="#3-初始化每个segment" class="headerlink" title="3. 初始化每个segment"></a>3. 初始化每个segment</h3><p>cap是每个segment里的HashEntry数组的长度，它等于initialCapacity/ssize的倍数c。</p>
<p>segment的容量threshold=(int)cap*loadFactor，默认情况下initialCapacity等于16，loadfactor等于0.75。</p>
<p><strong>可以看到这里的segment元素就类似于原先HashMap的结构，segment的每个元素内都存有类似HashMap的数组链表结构</strong>(如上图)。</p>
<h2 id="如何定位Segment"><a href="#如何定位Segment" class="headerlink" title="如何定位Segment"></a>如何定位Segment</h2><p>ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素时，必须先通过散列算法来定位到Segment。</p>
<pre><code class="java">   private static int hash(int h) {
        // Spread bits to regularize both segment and index locations,
        // using variant of single-word Wang/Jenkins hash.
        h += (h &lt;&lt;  15) ^ 0xffffcd7d;
        h ^= (h &gt;&gt;&gt; 10);
        h += (h &lt;&lt;   3);
        h ^= (h &gt;&gt;&gt;  6);
        h += (h &lt;&lt;   2) + (h &lt;&lt; 14);
        return h ^ (h &gt;&gt;&gt; 16);
    }</code></pre>
<p>首先会使用Wang/Jekins hash的变种算法对元素的hashCode进行一次再散列，之所进行再散列是为了避免散列冲突，使元素均匀地分布在不同的Segment上，从而提高容器的存取效率。ConcurrentHashMap通过以上hash算法对hashCode计算出的hash值以后再通过以下散列算法定位segment。</p>
<pre><code class="java">    private Segment&lt;K,V&gt; segmentForHash(int h) {
        long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;
        return (Segment&lt;K,V&gt;) UNSAFE.getObjectVolatile(segments, u);
    }</code></pre>
<p>默认情况下segmentShift为28，segmentMask为15，再散列后的数最大是32位二进制数据。</p>
<p>向右无符号移动28位，相当于让高4位参与到散列运算中，<code>(h &gt;&gt;&gt; segmentShift) &amp; segmentMask</code>的运算结构是4、15、7和8，可以看到散列值没有发生冲突。</p>
<h2 id="JDK-1-7-ConcurrentHashMap的操作"><a href="#JDK-1-7-ConcurrentHashMap的操作" class="headerlink" title="JDK 1.7 ConcurrentHashMap的操作"></a>JDK 1.7 ConcurrentHashMap的操作</h2><p>主要介绍get 、put、size操作。</p>
<h3 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h3><pre><code class="java">    public V get(Object key) {
        Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead
        HashEntry&lt;K,V&gt;[] tab;
        int h = hash(key.hashCode());
        long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;
        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;
            (tab = s.table) != null) {
            for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile
                     (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);
                 e != null; e = e.next) {
                K k;
                if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))
                    return e.value;
            }
        }
        return null;
    }</code></pre>
<p>get的高效之处在于，整个get过程不加锁，主要通过UNSAFE的getObjectVolatile方法获取值，即直接获取volatile的值。</p>
<p><code>UNSAFE.getObjectVolatile(tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE)</code>获取HashEntry数组节点表示的链表元素时定位的<code>(tab.length - 1) &amp; h)</code>直接使用的是再散列后的值，而定位segment是通过再散列的值的高位来定位的。</p>
<p>其目的是避免两次散列后的值一样，虽然元素Segment里散列开了，但却没有在HashEntry里散列开来。</p>
<h3 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h3><p>在操作共享变量时必须加锁。put方法首先定位到Segment，然后在Segment里进行插入操作。</p>
<pre><code class="java">    public V put(K key, V value) {
        Segment&lt;K,V&gt; s;
        if (value == null)
            throw new NullPointerException();
        int hash = hash(key.hashCode());
        int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;
        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck
             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment
            s = ensureSegment(j);
        return s.put(key, hash, value, false);
    }</code></pre>
<p>Segment的插入操作：</p>
<pre><code class="java">        final V put(K key, int hash, V value, boolean onlyIfAbsent) {
            HashEntry&lt;K,V&gt; node = tryLock() ? null :
                scanAndLockForPut(key, hash, value);
            V oldValue;
            try {
                HashEntry&lt;K,V&gt;[] tab = table;
                int index = (tab.length - 1) &amp; hash;
                HashEntry&lt;K,V&gt; first = entryAt(tab, index);
                for (HashEntry&lt;K,V&gt; e = first;;) {
                    if (e != null) {
                        K k;
                        if ((k = e.key) == key ||
                            (e.hash == hash &amp;&amp; key.equals(k))) {
                            oldValue = e.value;
                            if (!onlyIfAbsent) {
                                e.value = value;
                                ++modCount;
                            }
                            break;
                        }
                        e = e.next;
                    }
                    else {
                        if (node != null)
                            node.setNext(first);
                        else
                            node = new HashEntry&lt;K,V&gt;(hash, key, value, first);
                        int c = count + 1;
                        if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)
                            rehash(node);
                        else
                            setEntryAt(tab, index, node);
                        ++modCount;
                        count = c;
                        oldValue = null;
                        break;
                    }
                }
            } finally {
                unlock();
            }
            return oldValue;
        }</code></pre>
<ol>
<li><p>是否需要扩容</p>
<p>在插入元素要判断<code>c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY</code>是否超过阈值，超过需要对数组扩容rehash。这扩容方式比HashMap更合理，HashMap是在插入元素后看是否达到容量扩容的，而如果后续没有新元素了，那这次扩容就变多余了，而ConcurrentHashMap是在插入元素前判断的。</p>
</li>
<li><p>如何扩容</p>
<p>在扩容的时候，首先会创建一个容量是原来两倍的数组，然后将原有数组里的元素进行再散列后插入到新数组里。为了高效，ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容。</p>
</li>
</ol>
<h3 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h3><pre><code class="java">    public int size() {
        // Try a few times to get accurate count. On failure due to
        // continuous async changes in table, resort to locking.
        final Segment&lt;K,V&gt;[] segments = this.segments;
        int size;
        boolean overflow; // true if size overflows 32 bits
        long sum;         // sum of modCounts
        long last = 0L;   // previous sum
        int retries = -1; // first iteration isn&#39;t retry
        try {
            for (;;) {
                if (retries++ == RETRIES_BEFORE_LOCK) {
                    for (int j = 0; j &lt; segments.length; ++j)
                        ensureSegment(j).lock(); // force creation
                }
                sum = 0L;
                size = 0;
                overflow = false;
                for (int j = 0; j &lt; segments.length; ++j) {
                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);
                    if (seg != null) {
                        sum += seg.modCount;
                        int c = seg.count;
                        if (c &lt; 0 || (size += c) &lt; 0)
                            overflow = true;
                    }
                }
                if (sum == last)
                    break;
                last = sum;
            }
        } finally {
            if (retries &gt; RETRIES_BEFORE_LOCK) {
                for (int j = 0; j &lt; segments.length; ++j)
                    segmentAt(segments, j).unlock();
            }
        }
        return overflow ? Integer.MAX_VALUE : size;
    }</code></pre>
<p>直接统计每个Segment下的count值，显然不安全。又或者把segment的put、remove、clean方法全部锁住，但是这种方式非常低效。</p>
<p>CountHashMap的做法是：</p>
<p>线程尝试2次不锁住Segment的方式来统计个Segment大小，如果统计过程中，容器count值发生改变，则再采用加锁的方式来统计所有Segment的大小。</p>
<p>那么，ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化了呢？答案是，跟之前一样使用modCount变量，在put、remove和clean方法里操作元素前都会讲变量modCount进行加1，那么在统计size前后比较modeCount是否发生变化，从而得知容器大小是否发生改变。</p>
<h1 id="JDK-1-8-之后的ConcurrentHashMap"><a href="#JDK-1-8-之后的ConcurrentHashMap" class="headerlink" title="JDK 1.8+之后的ConcurrentHashMap"></a>JDK 1.8+之后的ConcurrentHashMap</h1><p>在JDK1.8之后，ConcurrentHashMap发生了那些变化呢？</p>
<ul>
<li>总体结构上，它的内部存储变得与HashMap结构非常类似，同样是大的桶(数组)，然后内部也是一个个所谓的链表结构(bin)，同步的粒度更细致一些。</li>
<li>其内部仍然有Segment定义，但仅仅是位了保证序列化时的兼容性而已，不再有任何结构上的用处。</li>
<li>因为不再使用Segment，初始化操作大大简化，改为lazy-load形式，这样可以有效避免初始开销，解决了老版本很多人抱怨的这一点。</li>
<li>数据存储利用volatile来保证可见性。</li>
<li>使用CAS等操作，在特定场景下进行无锁并发操作。</li>
<li>使用Unsafe、LongAdder之类的底层手段，进行极端情况的优化。</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><pre><code class="java">    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        final int hash;
        final K key;
        volatile V val;
        volatile Node&lt;K,V&gt; next;

                //其他代码略
    }</code></pre>
<p>这里不在介绍get和构造函数了，直接来看put的源码是怎么实现的。</p>
<h2 id="put操作-1"><a href="#put操作-1" class="headerlink" title="put操作"></a>put操作</h2><pre><code class="java">    final V putVal(K key, V value, boolean onlyIfAbsent) {
        if (key == null || value == null) throw new NullPointerException();
        int hash = spread(key.hashCode());
        int binCount = 0;
        for (Node&lt;K,V&gt;[] tab = table;;) {
            Node&lt;K,V&gt; f; int n, i, fh;
            if (tab == null || (n = tab.length) == 0)
                tab = initTable();
            else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
              //(1)利用CAS进行无锁线程安全操作，如果修改元素数组链表的对应元素为空，曾使用cas设置数组的元素作为链表的头元素
                if (casTabAt(tab, i, null,
                             new Node&lt;K,V&gt;(hash, key, value, null)))
                    break;                   // no lock when adding to empty bin
            }
            else if ((fh = f.hash) == MOVED)
                tab = helpTransfer(tab, f);
            else {
                V oldVal = null;
                synchronized (f) { //(2)
                    if (tabAt(tab, i) == f) {//double check f
                        if (fh &gt;= 0) {
                            binCount = 1;
                            for (Node&lt;K,V&gt; e = f;; ++binCount) {
                                K ek;
                                if (e.hash == hash &amp;&amp;
                                    ((ek = e.key) == key ||
                                     (ek != null &amp;&amp; key.equals(ek)))) {
                                    oldVal = e.val;
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                }
                                Node&lt;K,V&gt; pred = e;
                                if ((e = e.next) == null) {
                                    pred.next = new Node&lt;K,V&gt;(hash, key,
                                                              value, null);
                                    break;
                                }
                            }
                        }
                        else if (f instanceof TreeBin) { //树化节点
                            Node&lt;K,V&gt; p;
                            binCount = 2;
                            if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                           value)) != null) {
                                oldVal = p.val;
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                    }
                }
                if (binCount != 0) {
                    if (binCount &gt;= TREEIFY_THRESHOLD)//(3)超过树化阈值
                        treeifyBin(tab, i);
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
        }
        addCount(1L, binCount);
        return null;
    }</code></pre>
<ul>
<li>(1) 利用CAS进行无锁线程安全操作，如果修改元素数组链表的对应元素为空，曾使用cas设置数组的元素作为链表的头元素</li>
<li>(2) 根据如果当前链表的头节点也就是table数组元素f非空，那么对f加锁并插入f对应的链表中。当然如果f是树化节点TreeBin，则以树化的方式插入。这里tabAt调用了两次一次是判断是不是空的时候，一次是重新定位判断是不是f本身，都是为了避免f已经被人修改的线程安全问题。</li>
<li>(3)如果当前链表长度Bin的大小大于树化的阈值TREEIFY_THRESHOLD(默认8)则进行树化。</li>
</ul>
<p>这里有几处优化，如：</p>
<ul>
<li>一处是当链表对应头节点组成的数组元素是空的时候需要调用<code>tab = initTable();</code>来初始化当前新增元素作为链表数组的一个元素。</li>
</ul>
<pre><code class="java">    private final Node&lt;K,V&gt;[] initTable() {
        Node&lt;K,V&gt;[] tab; int sc;
        while ((tab = table) == null || tab.length == 0) {
            if ((sc = sizeCtl) &lt; 0)
                Thread.yield(); // lost initialization race; just spin
            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
                try {
                    if ((tab = table) == null || tab.length == 0) {
                        int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;
                        @SuppressWarnings(&quot;unchecked&quot;)
                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];
                        table = tab = nt;
                        sc = n - (n &gt;&gt;&gt; 2);
                    }
                } finally {
                    sizeCtl = sc;
                }
                break;
            }
        }
        return tab;
    }
</code></pre>
<p>这里用了<code>compareAndSwapInt</code> 并且使用volatile变量SIZECTL控制数组容量这个共享变量的线程安全。</p>
<ul>
<li>第二处是在定位hash位置处的链表头节点元素时：</li>
</ul>
<pre><code class="java">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) {
    return (Node&lt;K,V&gt;)U.getObjectAcquire(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);
}</code></pre>
<p>通过使用Unsafe进行优化，避免间接调用的开销。</p>
<h2 id="size操作-1"><a href="#size操作-1" class="headerlink" title="size操作"></a>size操作</h2><pre><code class="java">    public int size() {
        long n = sumCount();
        return ((n &lt; 0L) ? 0 :
                (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :
                (int)n);
    }</code></pre>
<p>其中sumCount源码如下：</p>
<pre><code class="java">    /**
     * A padded cell for distributing counts.  Adapted from LongAdder
     * and Striped64.  See their internal docs for explanation.
     */
    @sun.misc.Contended static final class CounterCell {
        volatile long value;
        CounterCell(long x) { value = x; }
    }

    final long sumCount() {
        CounterCell[] as = counterCells; CounterCell a;
        long sum = baseCount;
        if (as != null) {
            for (int i = 0; i &lt; as.length; ++i) {
                if ((a = as[i]) != null)
                    sum += a.value;
            }
        }
        return sum;
    }</code></pre>
<p>这里的计数用到了CounterCell这个类，数据一致性是怎么保证的？</p>
<p>对于CounterCell的操作，是基于<code>java.util.concurrent.atomic.LongAdder</code>进行的，是一种利用空间换时间的更高效的方法了，利用了Striped64内部的复杂逻辑。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://my.oschina.net/pingpangkuangmo/blog/817973" target="_blank" rel="noopener">* jdk1.8的HashMap和ConcurrentHashMap </a></p>
<p><a href="https://www.wanaright.com/2018/09/30/java10-concurrenthashmap-no-segment-lock/" target="_blank" rel="noopener">Java8之后的ConcurrentHashMap, 舍弃分段锁</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1509556" target="_blank" rel="noopener">java8的ConcurrentHashMap为何放弃分段锁</a> 这篇文章讲到了jdk 1.7分段锁的劣势</p>

    </div>

  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">Posts</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#为什么引入ConcurrentHashMap"><span class="toc-text">为什么引入ConcurrentHashMap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK-1-7的ConcurrentHashMap"><span class="toc-text">JDK 1.7的ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-1-7的ConcurrentHashMap的结构"><span class="toc-text">JDK 1.7的ConcurrentHashMap的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-1-7-ConcurrentHashMap初始化"><span class="toc-text">JDK 1.7 ConcurrentHashMap初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-初始化segment数组"><span class="toc-text">1. 初始化segment数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-初始化segmentShift和segmentMask"><span class="toc-text">2. 初始化segmentShift和segmentMask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-初始化每个segment"><span class="toc-text">3. 初始化每个segment</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何定位Segment"><span class="toc-text">如何定位Segment</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-1-7-ConcurrentHashMap的操作"><span class="toc-text">JDK 1.7 ConcurrentHashMap的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#get操作"><span class="toc-text">get操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put操作"><span class="toc-text">put操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#size操作"><span class="toc-text">size操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK-1-8-之后的ConcurrentHashMap"><span class="toc-text">JDK 1.8+之后的ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构"><span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#put操作-1"><span class="toc-text">put操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#size操作-1"><span class="toc-text">size操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol>
  </div>


  </div>
</div>
<div class="copyright">
    <span>本作品采用</span>
    <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>


  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2019/10/22/Algorithms_DS_DS_Link/" rel="next" title="【数据结构与算法】-【数据结构篇】链表">
          【数据结构与算法】-【数据结构篇】链表
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/2019/10/30/Algorithms_AL_Sort/" rel="prev" title="【数据结构与算法】-【算法】排序">
            【数据结构与算法】-【算法】排序
          </a>
          <span>〉</span>
        
      </div>
    </div>
  

    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <div id="gitalk-container"></div>
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script type="text/javascript">
        var gitalk = new Gitalk({
            clientID: 'xxx',
            clientSecret: 'xxx',
            id: window.location.pathname,
            repo: 'issue repo name',
            owner: 'Github username',
            admin: 'github username'
        })
        gitalk.render('gitalk-container')
    </script>



    </div>

    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" href="https://github.com/fooying" target="_blank">GitHub</a> |
        <a class="bottom-item" href="/links">友情链接</a> |
        <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> |
        <a class="bottom-item" href="https://github.com/fooying/hexo-theme-xoxo-plus" target="_blank">Theme xoxo-plus</a> |
        <a class="bottom-item" href="/atom.xml">RSS</a>
    </div>
</footer>

  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



  
<script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
</script>


</body>
</html>
