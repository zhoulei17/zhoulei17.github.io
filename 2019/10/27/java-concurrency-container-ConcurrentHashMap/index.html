<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>【并发容器和框架】一、CocurrentHashMap的实现原理与使用 | Z.L&#39;s blog</title>
  <meta name="keywords" content=" java , 并发容器 , ConcurrentHashMap ">
  <meta name="description" content="【并发容器和框架】一、CocurrentHashMap的实现原理与使用 | Z.L&#39;s blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="关于我前3年工作于华为苏州NCE公共开发部，Java软件工程师。微服务间的通信(Restful&#x2F;RPC)及编程框架是当时的工作关注点。能将产品传统的OSGI架构SOA项目服务化中心化并顺利上车很有成就感。现就职于一家创业公司并工作1年多，主攻Solr&#x2F;Lucene，给用户提供更爽的搜索体验。 热爱摄影、数码、追求新鲜的事物，关注生活中的美好，并喜欢用相机记录下来。 还有，学习是一个非常愉快的过程。">
<meta property="og:type" content="website">
<meta property="og:title" content="about">
<meta property="og:url" content="2tongtong.cn/about/index.html">
<meta property="og:site_name" content="Z.L&#39;s blog">
<meta property="og:description" content="关于我前3年工作于华为苏州NCE公共开发部，Java软件工程师。微服务间的通信(Restful&#x2F;RPC)及编程框架是当时的工作关注点。能将产品传统的OSGI架构SOA项目服务化中心化并顺利上车很有成就感。现就职于一家创业公司并工作1年多，主攻Solr&#x2F;Lucene，给用户提供更爽的搜索体验。 热爱摄影、数码、追求新鲜的事物，关注生活中的美好，并喜欢用相机记录下来。 还有，学习是一个非常愉快的过程。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-03-21T07:43:06.000Z">
<meta property="article:modified_time" content="2020-03-22T12:37:50.926Z">
<meta property="article:author" content="Zhou Lei">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.0.1" rel="stylesheet">

<link href="/css/hl_theme/darcula.css?v=1.0.1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1.0.1" ></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.0.1" ></script>

<meta name="generator" content="Hexo 4.2.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
  <input class="theme_blog_path" value="">
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>Zhou Lei</span>
</div>

<div class="icon">
    
        
        <a title="rss" href="/atom.xml" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-rss"></use>
                </svg>
            
        </a>
        
    
        
        <a title="github" href="https://github.com/yelog" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
        <a title="weibo" href="http://weibo.com/u/2307534817" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-weibo"></use>
                </svg>
            
        </a>
        
    
        
        <a title="jianshu" href="https://www.jianshu.com/u/ff56736de7cf" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-jianshu"></use>
                </svg>
            
        </a>
        
    
        
        <a title="zhihu" href="https://www.zhihu.com/people/jaytp/activities" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-zhihu"></use>
                </svg>
            
        </a>
        
    
        
    
        
        <a title="email" href="mailto:tcals1@163.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=541732905&site=qq&menu=yes" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-qq"></use>
                </svg>
            
        </a>
        
    
</div>




<ul>
    <li><div class="all active">全部文章</div></li>
    
        
            
            <li><div data-rel="Jetty">Jetty</div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="opendaylight">opendaylight</div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="HTTP">HTTP</div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="工具">工具</div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="Java"><i class="fold iconfont icon-right"></i>Java</div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="并发编程">并发编程</div>
                            
                        </li>
                            
                        <li><div data-rel="集合">集合</div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="职业生涯">职业生涯</div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="数据结构与算法">数据结构与算法</div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="NLP">NLP</div>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
            <li><div data-rel="Solr">Solr</div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="Lucene">Lucene</div>
                
            </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="about  hasFriend  site_url"  href="/about">关于</a><a style="width: 50%"  class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="53">
<input type="hidden" id="yelog_site_word_count" value="111.9k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="/fengqinglei.top">fengqinglei</a></li>
            
            <li><a target="_blank" href="https://imququ.com/post/archives.html">Jerry Qu</a></li>
            
            <li><a target="_blank" href="https://www.sczyh30.com/">浮生若梦</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode === 13){return false;}">
        <input id="local-search-input" class="search" type="text" placeholder="Search..." />
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none" />
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a class="color1">Jetty</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">odl</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">rpc</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">HTTP</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">HTTP2</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">Markdown</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">java</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">LinkedList</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">Collection</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">集合</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">work summary</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">HashMap</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">数据结构</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">链表</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">LinkedHashMap</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">算法</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">排序</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">ArrayList</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">随机梯度下降</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">有监督</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">线性回归</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">并发框架</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">Executor</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">并发容器</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">ConcurrentHashMap</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">ForkJoin</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">ThreadPool</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">并发</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">java红黑树</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">操作系统</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">进程</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">线程</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">Search</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">Solr</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">死锁</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">线程的风险</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">互斥锁</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">管程</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">生命周期</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">线程协作</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">wait</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">阻塞队列</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">信号量</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">互斥</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">可见性</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">volatile</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">ReadWriteLock</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">synchronized</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">Json Facet</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">lock</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">原子操作</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">Lucene</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">索引文件</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">Lucene工具类</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">DocValues</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">idea</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">Collector</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">Lucene压缩算法</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <nav id="title-list-nav">
        
        <a  class="Jetty "
           href="/2015/11/05/jetty-source-connection/"
           data-tag="Jetty"
           data-author="" >
            <span class="post-title" title="【Jetty源码阅读系列】二、连接管理">【Jetty源码阅读系列】二、连接管理</span>
            <!--span class="post-date" title="2015-11-05 00:00:00">2015/11/05</span-->
        </a>
        
        <a  class="opendaylight "
           href="/2019/11/27/ODL-mdsal-codereview/"
           data-tag="odl,rpc"
           data-author="" >
            <span class="post-title" title="【opendaylight】——MD-SAL服务总线RPC服务源码分析">【opendaylight】——MD-SAL服务总线RPC服务源码分析</span>
            <!--span class="post-date" title="2019-11-27 00:00:00">2019/11/27</span-->
        </a>
        
        <a  class="opendaylight "
           href="/2019/11/27/ODL-RPC-module/"
           data-tag="odl,rpc"
           data-author="" >
            <span class="post-title" title="【opendaylight】——MD-SAL RPC源码概览">【opendaylight】——MD-SAL RPC源码概览</span>
            <!--span class="post-date" title="2019-11-27 00:00:00">2019/11/27</span-->
        </a>
        
        <a  class="HTTP "
           href="/2015/11/11/http2-features-introduce/"
           data-tag="HTTP,HTTP2"
           data-author="" >
            <span class="post-title" title="HTTP/2特性总结">HTTP/2特性总结</span>
            <!--span class="post-date" title="2015-11-11 00:00:00">2015/11/11</span-->
        </a>
        
        <a  class="工具 "
           href="/2015/11/04/2018-11-4-markdown-studying-knowledage/"
           data-tag="Markdown"
           data-author="" >
            <span class="post-title" title="Markdown学习笔记">Markdown学习笔记</span>
            <!--span class="post-date" title="2015-11-04 00:00:00">2015/11/04</span-->
        </a>
        
        <a  class="Java 集合 "
           href="/2019/01/16/2019-1-16-java-collection-LinkedList/"
           data-tag="java,LinkedList,Collection,集合"
           data-author="" >
            <span class="post-title" title="【Java集合】-LinkedList">【Java集合】-LinkedList</span>
            <!--span class="post-date" title="2019-01-16 00:00:00">2019/01/16</span-->
        </a>
        
        <a  class="职业生涯 "
           href="/2018/10/12/2018-11-4-thinking-huawei-workreview/"
           data-tag="work summary"
           data-author="" >
            <span class="post-title" title="【职业生涯】2016～2018工作总结">【职业生涯】2016～2018工作总结</span>
            <!--span class="post-date" title="2018-10-12 00:00:00">2018/10/12</span-->
        </a>
        
        <a  class="Java 集合 "
           href="/2019/01/20/2019-1-20-java-collection-HashMap/"
           data-tag="java,Collection,集合,HashMap"
           data-author="" >
            <span class="post-title" title="【Java集合】-HashMap">【Java集合】-HashMap</span>
            <!--span class="post-date" title="2019-01-20 00:00:00">2019/01/20</span-->
        </a>
        
        <a  class="数据结构与算法 "
           href="/2019/10/22/Algorithms_DS_DS_Link/"
           data-tag="数据结构,链表"
           data-author="" >
            <span class="post-title" title="【数据结构与算法】-【数据结构篇】链表">【数据结构与算法】-【数据结构篇】链表</span>
            <!--span class="post-date" title="2019-10-22 00:00:00">2019/10/22</span-->
        </a>
        
        <a  class="Java 集合 "
           href="/2019/01/31/2019-1-31-java-collection-LinkedHashMap/"
           data-tag="java,Collection,集合,LinkedHashMap"
           data-author="" >
            <span class="post-title" title="【Java集合】-LinkedHashMap">【Java集合】-LinkedHashMap</span>
            <!--span class="post-date" title="2019-01-31 00:00:00">2019/01/31</span-->
        </a>
        
        <a  class="数据结构与算法 "
           href="/2019/10/30/Algorithms_AL_Sort/"
           data-tag="算法,排序"
           data-author="" >
            <span class="post-title" title="【数据结构与算法】-【算法】排序">【数据结构与算法】-【算法】排序</span>
            <!--span class="post-date" title="2019-10-30 00:00:00">2019/10/30</span-->
        </a>
        
        <a  class="Java 集合 "
           href="/2019/01/15/2019-1-15-java-collection-ArrayList/"
           data-tag="java,Collection,集合,ArrayList"
           data-author="" >
            <span class="post-title" title="【Java集合】-ArrayList">【Java集合】-ArrayList</span>
            <!--span class="post-date" title="2019-01-15 00:00:00">2019/01/15</span-->
        </a>
        
        <a  class="NLP "
           href="/2019/11/27/NLP-Gradient-Descent/"
           data-tag="随机梯度下降,有监督,线性回归"
           data-author="" >
            <span class="post-title" title="【NLP】一、线性回归与随机梯度下降法">【NLP】一、线性回归与随机梯度下降法</span>
            <!--span class="post-date" title="2019-11-27 00:00:00">2019/11/27</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/11/27/java-concurrency-container-Executor/"
           data-tag="java,并发框架,Executor"
           data-author="" >
            <span class="post-title" title="【并发容器和框架】四、Executor框架">【并发容器和框架】四、Executor框架</span>
            <!--span class="post-date" title="2019-11-27 00:00:00">2019/11/27</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/10/27/java-concurrency-container-ConcurrentHashMap/"
           data-tag="java,并发容器,ConcurrentHashMap"
           data-author="" >
            <span class="post-title" title="【并发容器和框架】一、CocurrentHashMap的实现原理与使用">【并发容器和框架】一、CocurrentHashMap的实现原理与使用</span>
            <!--span class="post-date" title="2019-10-27 00:00:00">2019/10/27</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/11/06/java-concurrency-container-ForkJoin/"
           data-tag="java,并发框架,ForkJoin"
           data-author="" >
            <span class="post-title" title="【并发容器和框架】二、Fork/Join框架">【并发容器和框架】二、Fork/Join框架</span>
            <!--span class="post-date" title="2019-11-06 00:00:00">2019/11/06</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/12/23/java-concurrency-container-ThreadPool/"
           data-tag="java,并发框架,ThreadPool"
           data-author="" >
            <span class="post-title" title="【并发容器和框架】三、Java线程池的实现原理和使用">【并发容器和框架】三、Java线程池的实现原理和使用</span>
            <!--span class="post-date" title="2019-12-23 00:00:00">2019/12/23</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/03/04/2019-3-04-java-concurrency-catalog/"
           data-tag="java,并发"
           data-author="" >
            <span class="post-title" title="【目录】">【目录】</span>
            <!--span class="post-date" title="2019-03-04 00:00:00">2019/03/04</span-->
        </a>
        
        <a  class="数据结构与算法 "
           href="/2019/01/31/2019-2-1-java-collection-red-black-tree/"
           data-tag="Collection,算法,java红黑树"
           data-author="" >
            <span class="post-title" title="【数据结构与算法】Java中Map用到的数据结构:红黑树">【数据结构与算法】Java中Map用到的数据结构:红黑树</span>
            <!--span class="post-date" title="2019-01-31 00:00:00">2019/01/31</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/02/27/2019-2-27-java-concurrency-overview/"
           data-tag="java,并发"
           data-author="" >
            <span class="post-title" title="【开篇】-全景图">【开篇】-全景图</span>
            <!--span class="post-date" title="2019-02-27 00:00:00">2019/02/27</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/03/04/2019-3-06-java-concurrency-system/"
           data-tag="操作系统,进程,线程"
           data-author="" >
            <span class="post-title" title="【基本概念篇】一、认识进程与线程">【基本概念篇】一、认识进程与线程</span>
            <!--span class="post-date" title="2019-03-04 00:00:00">2019/03/04</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/03/08/2019-3-08-java-concurreny-use-thread/"
           data-tag="java,并发"
           data-author="" >
            <span class="post-title" title="【基本概念篇】二、线程基本使用">【基本概念篇】二、线程基本使用</span>
            <!--span class="post-date" title="2019-03-08 00:00:00">2019/03/08</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/03/09/2019-3-09-java-concurreny-control-thread/"
           data-tag="java,并发"
           data-author="" >
            <span class="post-title" title="【基本概念篇】三、控制线程">【基本概念篇】三、控制线程</span>
            <!--span class="post-date" title="2019-03-09 00:00:00">2019/03/09</span-->
        </a>
        
        <a  class=""
           href="/2019/03/29/2019-3-29-search-engine-solrcloud/"
           data-tag="Search,Solr"
           data-author="" >
            <span class="post-title" title="Solr-SolrCloud核心概念">Solr-SolrCloud核心概念</span>
            <!--span class="post-date" title="2019-03-29 00:00:00">2019/03/29</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/04/11/2019-4-11-java-concurreny-concept-3Bug/"
           data-tag="java,并发"
           data-author="" >
            <span class="post-title" title="【基本概念篇】四、并发编程的3个问题（可见性、原子性、有序性问题）">【基本概念篇】四、并发编程的3个问题（可见性、原子性、有序性问题）</span>
            <!--span class="post-date" title="2019-04-11 00:00:00">2019/04/11</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/04/21/2019-4-21-java-concurreny-deadlock/"
           data-tag="java,并发,死锁"
           data-author="" >
            <span class="post-title" title="【基本概念篇】七、死锁">【基本概念篇】七、死锁</span>
            <!--span class="post-date" title="2019-04-21 00:00:00">2019/04/21</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/04/13/2019-4-13-java-concurreny-memory-model/"
           data-tag="java,并发"
           data-author="" >
            <span class="post-title" title="【基本概念篇】五、Java内存模型：看Java如何解决可见性和有序性问题">【基本概念篇】五、Java内存模型：看Java如何解决可见性和有序性问题</span>
            <!--span class="post-date" title="2019-04-13 00:00:00">2019/04/13</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/04/21/2019-5-07-java-concurreny-safey-performence/"
           data-tag="java,并发,死锁,线程的风险"
           data-author="" >
            <span class="post-title" title="【基本概念篇】八、安全性、活跃性、性能问题">【基本概念篇】八、安全性、活跃性、性能问题</span>
            <!--span class="post-date" title="2019-04-21 00:00:00">2019/04/21</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/04/20/2019-4-20-java-concurrency-lock/"
           data-tag="java,并发,互斥锁"
           data-author="" >
            <span class="post-title" title="【基本概念篇】六、互斥锁：解决原子性问题">【基本概念篇】六、互斥锁：解决原子性问题</span>
            <!--span class="post-date" title="2019-04-20 00:00:00">2019/04/20</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/05/09/2019-5-09-java-concurreny-system-courrenency/"
           data-tag="并发,操作系统,管程"
           data-author="" >
            <span class="post-title" title="【基本概念篇】九、从操作系统角度看并发">【基本概念篇】九、从操作系统角度看并发</span>
            <!--span class="post-date" title="2019-05-09 00:00:00">2019/05/09</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/05/15/2019-5-15-java-concurreny-java-thread-status/"
           data-tag="java,并发,生命周期"
           data-author="" >
            <span class="post-title" title="【基本概念篇】十一、Java线程的状态和生命周期">【基本概念篇】十一、Java线程的状态和生命周期</span>
            <!--span class="post-date" title="2019-05-15 00:00:00">2019/05/15</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/05/15/2019-5-22-java-concurreny-how-to-dev-objshare/"
           data-tag="java,并发"
           data-author="" >
            <span class="post-title" title="【基本概念篇】十二、如何构建线程安全的对象——对象的共享">【基本概念篇】十二、如何构建线程安全的对象——对象的共享</span>
            <!--span class="post-date" title="2019-05-15 00:00:00">2019/05/15</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/05/10/2019-5-10-java-concurreny-java-monitor/"
           data-tag="java,并发,管程"
           data-author="" >
            <span class="post-title" title="【基本概念篇】十、管程——并发编程的万能钥匙">【基本概念篇】十、管程——并发编程的万能钥匙</span>
            <!--span class="post-date" title="2019-05-10 00:00:00">2019/05/10</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/06/19/2019-6-19-java-concurrency-communication-wait-notify/"
           data-tag="java,并发,线程协作,wait"
           data-author="" >
            <span class="post-title" title="【线程协作篇】一、wait、notify、notifyAll&amp;Lock、Condition">【线程协作篇】一、wait、notify、notifyAll&amp;Lock、Condition</span>
            <!--span class="post-date" title="2019-06-19 00:00:00">2019/06/19</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/07/04/2019-7-04-java-concurrency-communication-queue/"
           data-tag="java,并发,线程协作,阻塞队列"
           data-author="" >
            <span class="post-title" title="【线程协作篇】二、生产者与消费者与阻塞队列">【线程协作篇】二、生产者与消费者与阻塞队列</span>
            <!--span class="post-date" title="2019-07-04 00:00:00">2019/07/04</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/07/06/2019-7-06-java-concurrency-communication-semphore/"
           data-tag="java,并发,线程协作,信号量"
           data-author="" >
            <span class="post-title" title="【线程协作篇】三、信号量Semaphore-控制临界区资源的多线程访问">【线程协作篇】三、信号量Semaphore-控制临界区资源的多线程访问</span>
            <!--span class="post-date" title="2019-07-06 00:00:00">2019/07/06</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/07/15/2019-7-15-java-concurrency-communication-CountDownLatch-CyclicBarrier/"
           data-tag="java,并发,线程协作,信号量"
           data-author="" >
            <span class="post-title" title="【线程协作篇】四、CountDownLatch和CyclicBarrier：如何让多线程步调一致">【线程协作篇】四、CountDownLatch和CyclicBarrier：如何让多线程步调一致</span>
            <!--span class="post-date" title="2019-07-15 00:00:00">2019/07/15</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/08/16/2019-8-16-java-concurrency-mutex-volatile/"
           data-tag="java,并发,互斥,可见性,volatile"
           data-author="" >
            <span class="post-title" title="【线程互斥篇】四、无锁方案-volatile原理与内存语义">【线程互斥篇】四、无锁方案-volatile原理与内存语义</span>
            <!--span class="post-date" title="2019-08-16 00:00:00">2019/08/16</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/07/31/2019-7-31-java-concurrency-Mutex-readwritelock/"
           data-tag="java,并发,互斥,ReadWriteLock"
           data-author="" >
            <span class="post-title" title="【线程互斥篇】二、有锁方案-读写锁ReadWriteLock——快速使用一个完备的缓存">【线程互斥篇】二、有锁方案-读写锁ReadWriteLock——快速使用一个完备的缓存</span>
            <!--span class="post-date" title="2019-07-31 00:00:00">2019/07/31</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/08/11/2019-8-11-java-concurrency-mutex-synchronized/"
           data-tag="java,并发,互斥,synchronized"
           data-author="" >
            <span class="post-title" title="【线程互斥篇】三、有锁方案-synchronized的实现原理与应用">【线程互斥篇】三、有锁方案-synchronized的实现原理与应用</span>
            <!--span class="post-date" title="2019-08-11 00:00:00">2019/08/11</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/08/23/2019-8-23-java-concurrency-mutex-final/"
           data-tag="java,并发,互斥,可见性,volatile"
           data-author="" >
            <span class="post-title" title="【线程互斥篇】五、无锁方案-不可变性final与内存语义">【线程互斥篇】五、无锁方案-不可变性final与内存语义</span>
            <!--span class="post-date" title="2019-08-23 00:00:00">2019/08/23</span-->
        </a>
        
        <a  class="Solr "
           href="/2019/11/27/Json%20Facet/"
           data-tag="Solr,Json Facet"
           data-author="" >
            <span class="post-title" title="【Solr应用】——Json Facet使用总结">【Solr应用】——Json Facet使用总结</span>
            <!--span class="post-date" title="2019-11-27 00:00:00">2019/11/27</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/07/29/2019-7-29-java-concurrency-Mutex-lock/"
           data-tag="java,并发,互斥,lock"
           data-author="" >
            <span class="post-title" title="【线程互斥篇】一、有锁方案-锁Lock(并发包中的管程)">【线程互斥篇】一、有锁方案-锁Lock(并发包中的管程)</span>
            <!--span class="post-date" title="2019-07-29 00:00:00">2019/07/29</span-->
        </a>
        
        <a  class="Java 并发编程 "
           href="/2019/09/01/2019-9-01-java-concurrency-mutex-atomic/"
           data-tag="java,并发,互斥,原子操作"
           data-author="" >
            <span class="post-title" title="【线程互斥篇】六、无锁方案-原子操作的实现原理">【线程互斥篇】六、无锁方案-原子操作的实现原理</span>
            <!--span class="post-date" title="2019-09-01 00:00:00">2019/09/01</span-->
        </a>
        
        <a  class="Lucene "
           href="/2020/01/31/lucene-indexfile-pos-pay/"
           data-tag="Search,Lucene,索引文件"
           data-author="" >
            <span class="post-title" title="【索引文件】.pos、.pay文件">【索引文件】.pos、.pay文件</span>
            <!--span class="post-date" title="2020-01-31 00:00:00">2020/01/31</span-->
        </a>
        
        <a  class="Lucene "
           href="/2020/02/02/lucene-indexfile-doc/"
           data-tag="Search,Lucene,索引文件"
           data-author="" >
            <span class="post-title" title="【索引文件】.doc文件">【索引文件】.doc文件</span>
            <!--span class="post-date" title="2020-02-02 00:00:00">2020/02/02</span-->
        </a>
        
        <a  class="Lucene "
           href="/2020/02/01/lucene-indexfile-tim-tip/"
           data-tag="Search,Lucene,索引文件"
           data-author="" >
            <span class="post-title" title="【索引文件】.tim、.tip文件">【索引文件】.tim、.tip文件</span>
            <!--span class="post-date" title="2020-02-01 00:00:00">2020/02/01</span-->
        </a>
        
        <a  class="Lucene "
           href="/2020/02/04/lucene-utils-fixedBitSet/"
           data-tag="Search,Lucene,Lucene工具类"
           data-author="" >
            <span class="post-title" title="【工具类】FixedBitSet">【工具类】FixedBitSet</span>
            <!--span class="post-date" title="2020-02-04 00:00:00">2020/02/04</span-->
        </a>
        
        <a  class="Lucene "
           href="/2020/01/31/lucene-indexfile-nvd-nvm/"
           data-tag="Search,Lucene,索引文件"
           data-author="" >
            <span class="post-title" title="【索引文件】.nvd、.nvm文件">【索引文件】.nvd、.nvm文件</span>
            <!--span class="post-date" title="2020-01-31 00:00:00">2020/01/31</span-->
        </a>
        
        <a  class="Lucene "
           href="/2020/02/07/lucene-dv-SortedDocValues/"
           data-tag="Search,Lucene,DocValues"
           data-author="" >
            <span class="post-title" title="【DocValues】一、SortedDocValues">【DocValues】一、SortedDocValues</span>
            <!--span class="post-date" title="2020-02-07 00:00:00">2020/02/07</span-->
        </a>
        
        <a  class="工具 "
           href="/2020/02/07/tools-idea-simple/"
           data-tag="idea"
           data-author="" >
            <span class="post-title" title="【工具使用】IEDA使用分享">【工具使用】IEDA使用分享</span>
            <!--span class="post-date" title="2020-02-07 00:00:00">2020/02/07</span-->
        </a>
        
        <a  class="Lucene "
           href="/2020/03/04/lucence-search-collector1/"
           data-tag="Search,Lucene,Collector"
           data-author="" >
            <span class="post-title" title="【Search】一、Collector">【Search】一、Collector</span>
            <!--span class="post-date" title="2020-03-04 00:00:00">2020/03/04</span-->
        </a>
        
        <a  class="Lucene "
           href="/2020/02/07/lucene-yasuocunchu-PackedInts/"
           data-tag="Search,Lucene,Lucene压缩算法"
           data-author="" >
            <span class="post-title" title="【压缩存储&amp;算法】PackedInts">【压缩存储&amp;算法】PackedInts</span>
            <!--span class="post-date" title="2020-02-07 00:00:00">2020/02/07</span-->
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-java-concurrency-container-ConcurrentHashMap" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">【并发容器和框架】一、CocurrentHashMap的实现原理与使用</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
                <a  data-rel="Java">Java</a>/
            
                <a  data-rel="并发编程">并发编程</a>
            
        </span>
        
        
        <span class="tag">
            
            <a class="color5">java</a>
            
            <a class="color5">并发容器</a>
            
            <a class="color3">ConcurrentHashMap</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title='更新时间: 2020-03-22 18:10:51'>2019-10-27 00:00</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:3.6k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#为什么引入ConcurrentHashMap"><span class="toc-text">为什么引入ConcurrentHashMap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK-1-7的ConcurrentHashMap"><span class="toc-text">JDK 1.7的ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-1-7的ConcurrentHashMap的结构"><span class="toc-text">JDK 1.7的ConcurrentHashMap的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-1-7-ConcurrentHashMap初始化"><span class="toc-text">JDK 1.7 ConcurrentHashMap初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-初始化segment数组"><span class="toc-text">1. 初始化segment数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-初始化segmentShift和segmentMask"><span class="toc-text">2. 初始化segmentShift和segmentMask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-初始化每个segment"><span class="toc-text">3. 初始化每个segment</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何定位Segment"><span class="toc-text">如何定位Segment</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-1-7-ConcurrentHashMap的操作"><span class="toc-text">JDK 1.7 ConcurrentHashMap的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#get操作"><span class="toc-text">get操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put操作"><span class="toc-text">put操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#size操作"><span class="toc-text">size操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK-1-8-之后的ConcurrentHashMap"><span class="toc-text">JDK 1.8+之后的ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构"><span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#put操作-1"><span class="toc-text">put操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#size操作-1"><span class="toc-text">size操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="为什么引入ConcurrentHashMap"><a href="#为什么引入ConcurrentHashMap" class="headerlink" title="为什么引入ConcurrentHashMap"></a>为什么引入ConcurrentHashMap</h1><p>在并发编程中使用HashMap可能导致程序死循环。而使用线程安全的HashTable效率又非常低下，基于以上两个原因，便有了ConcurrentHash的出现。</p>
<ul>
<li><p>线程不安全的HashMap</p>
<p>在多线程环境下，使用HashMap进行put操作会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。</p>
</li>
<li><p>效率低下的的HashTable</p>
<p>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。</p>
</li>
<li><p>ConcurrentHashMap的锁分段技术可有效提升并发率</p>
<p>HashTable在高并发下的效率低下的原因是因为所有访问HashTable的线程必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争。</p>
<p>存储数据时分成一段段存储，每一段分配一把锁，这样当一个线程访问其中一个段数据时，其他段数据依然可以被其他线程访问。</p>
</li>
</ul>
<p>  分段锁是JDK1.7及其之前的实现技术，JDK1.8并没有使用分段锁技术。</p>
<h1 id="JDK-1-7的ConcurrentHashMap"><a href="#JDK-1-7的ConcurrentHashMap" class="headerlink" title="JDK 1.7的ConcurrentHashMap"></a>JDK 1.7的ConcurrentHashMap</h1><p>ConcurrentHashMap的设计一直在演进中，JDK 1.7和JDK 1.8的ConcurrentHashMap实现存在巨大的差异，公司现在使用的是JDK 1.8，因此我们着重分析JDK 1.8，在此之前1.7也先介绍下。</p>
<h2 id="JDK-1-7的ConcurrentHashMap的结构"><a href="#JDK-1-7的ConcurrentHashMap的结构" class="headerlink" title="JDK 1.7的ConcurrentHashMap的结构"></a>JDK 1.7的ConcurrentHashMap的结构</h2><p>主要结构由：</p>
<ul>
<li>分离锁 <strong>Segment</strong>、Segment内部集成一个<strong>HashEntry</strong>的数组。<ul>
<li>Segment是一种可重入锁，一个ConcurrentHashMap包含一个Segment数组，一个Segment包含一个HashEntry数组。Segment的结构与HashMap类似是一种数组和链表的结构。</li>
<li>每个HashEntry是一个链表结构的元素。</li>
</ul>
</li>
<li>HashEntry内部使用volatile的value字段来保证可见性，也利用了不可变对象的机制以改进利用Unsafe提供的底层能力，比如volatile access，直接完成部分操作，以优化性能，毕竟Unsafe中的很多操作是JVM intrinsic优化过的。</li>
</ul>
<p><img src="/img/in-post/image-20191030234301439.png" alt=""></p>
<h2 id="JDK-1-7-ConcurrentHashMap初始化"><a href="#JDK-1-7-ConcurrentHashMap初始化" class="headerlink" title="JDK 1.7 ConcurrentHashMap初始化"></a>JDK 1.7 ConcurrentHashMap初始化</h2><h3 id="1-初始化segment数组"><a href="#1-初始化segment数组" class="headerlink" title="1. 初始化segment数组"></a>1. 初始化segment数组</h3><p>先看源码：</p>
<pre><code class="java">    public ConcurrentHashMap(int initialCapacity,
                             float loadFactor, int concurrencyLevel) {
        if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)
            throw new IllegalArgumentException();
        if (concurrencyLevel &gt; MAX_SEGMENTS)
            concurrencyLevel = MAX_SEGMENTS;
        // Find power-of-two sizes best matching arguments
        int sshift = 0;
        int ssize = 1;
        while (ssize &lt; concurrencyLevel) {
            ++sshift;
            ssize &lt;&lt;= 1;
        }
        this.segmentShift = 32 - sshift;
        this.segmentMask = ssize - 1;
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        int c = initialCapacity / ssize;
        if (c * ssize &lt; initialCapacity)
            ++c;
        int cap = MIN_SEGMENT_TABLE_CAPACITY;
        while (cap &lt; c)
            cap &lt;&lt;= 1;
        // create segments and segments[0]
        Segment&lt;K,V&gt; s0 =
            new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),
                             (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);
        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];
        UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
        this.segments = ss;
    }</code></pre>
<p>Segments的长度ssize由concurrencyLevel计算得到。为了能通过按位与的散列算法来定位segment数组的索引，必须保证segments数组的长度是2的N次方，所以必须计算出一个大于等于concurrencyLevel的最小的2的N次方值作为segments的长度。假如concurrencyLevel等于14、15或16，ssize都会等于16，即容器里锁的个数也是16。</p>
<h3 id="2-初始化segmentShift和segmentMask"><a href="#2-初始化segmentShift和segmentMask" class="headerlink" title="2. 初始化segmentShift和segmentMask"></a>2. 初始化segmentShift和segmentMask</h3><p>这两个全局变量是用来定位segment的散列算法里使用的，sshift等于ssize从1向左移位的次数。concurrencyLevel默认等于16，所以sshift等于4。</p>
<ul>
<li>segmentShift用与定位参与散列运算的位数，segmentShift等于32减sshift，所以等于28（之所以是32是因为hash()的最大输出是32）。</li>
<li>segmentMask是散列运算的掩码，等于ssize减1，即15，掩码的二进制各位都是1.因为ssize的最大值都是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。</li>
</ul>
<h3 id="3-初始化每个segment"><a href="#3-初始化每个segment" class="headerlink" title="3. 初始化每个segment"></a>3. 初始化每个segment</h3><p>cap是每个segment里的HashEntry数组的长度，它等于initialCapacity/ssize的倍数c。</p>
<p>segment的容量threshold=(int)cap*loadFactor，默认情况下initialCapacity等于16，loadfactor等于0.75。</p>
<p><strong>可以看到这里的segment元素就类似于原先HashMap的结构，segment的每个元素内都存有类似HashMap的数组链表结构</strong>(如上图)。</p>
<h2 id="如何定位Segment"><a href="#如何定位Segment" class="headerlink" title="如何定位Segment"></a>如何定位Segment</h2><p>ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素时，必须先通过散列算法来定位到Segment。</p>
<pre><code class="java">   private static int hash(int h) {
        // Spread bits to regularize both segment and index locations,
        // using variant of single-word Wang/Jenkins hash.
        h += (h &lt;&lt;  15) ^ 0xffffcd7d;
        h ^= (h &gt;&gt;&gt; 10);
        h += (h &lt;&lt;   3);
        h ^= (h &gt;&gt;&gt;  6);
        h += (h &lt;&lt;   2) + (h &lt;&lt; 14);
        return h ^ (h &gt;&gt;&gt; 16);
    }</code></pre>
<p>首先会使用Wang/Jekins hash的变种算法对元素的hashCode进行一次再散列，之所进行再散列是为了避免散列冲突，使元素均匀地分布在不同的Segment上，从而提高容器的存取效率。ConcurrentHashMap通过以上hash算法对hashCode计算出的hash值以后再通过以下散列算法定位segment。</p>
<pre><code class="java">    private Segment&lt;K,V&gt; segmentForHash(int h) {
        long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;
        return (Segment&lt;K,V&gt;) UNSAFE.getObjectVolatile(segments, u);
    }</code></pre>
<p>默认情况下segmentShift为28，segmentMask为15，再散列后的数最大是32位二进制数据。</p>
<p>向右无符号移动28位，相当于让高4位参与到散列运算中，<code>(h &gt;&gt;&gt; segmentShift) &amp; segmentMask</code>的运算结构是4、15、7和8，可以看到散列值没有发生冲突。</p>
<h2 id="JDK-1-7-ConcurrentHashMap的操作"><a href="#JDK-1-7-ConcurrentHashMap的操作" class="headerlink" title="JDK 1.7 ConcurrentHashMap的操作"></a>JDK 1.7 ConcurrentHashMap的操作</h2><p>主要介绍get 、put、size操作。</p>
<h3 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h3><pre><code class="java">    public V get(Object key) {
        Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead
        HashEntry&lt;K,V&gt;[] tab;
        int h = hash(key.hashCode());
        long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;
        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;
            (tab = s.table) != null) {
            for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile
                     (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);
                 e != null; e = e.next) {
                K k;
                if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))
                    return e.value;
            }
        }
        return null;
    }</code></pre>
<p>get的高效之处在于，整个get过程不加锁，主要通过UNSAFE的getObjectVolatile方法获取值，即直接获取volatile的值。</p>
<p><code>UNSAFE.getObjectVolatile(tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE)</code>获取HashEntry数组节点表示的链表元素时定位的<code>(tab.length - 1) &amp; h)</code>直接使用的是再散列后的值，而定位segment是通过再散列的值的高位来定位的。</p>
<p>其目的是避免两次散列后的值一样，虽然元素Segment里散列开了，但却没有在HashEntry里散列开来。</p>
<h3 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h3><p>在操作共享变量时必须加锁。put方法首先定位到Segment，然后在Segment里进行插入操作。</p>
<pre><code class="java">    public V put(K key, V value) {
        Segment&lt;K,V&gt; s;
        if (value == null)
            throw new NullPointerException();
        int hash = hash(key.hashCode());
        int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;
        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck
             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment
            s = ensureSegment(j);
        return s.put(key, hash, value, false);
    }</code></pre>
<p>Segment的插入操作：</p>
<pre><code class="java">        final V put(K key, int hash, V value, boolean onlyIfAbsent) {
            HashEntry&lt;K,V&gt; node = tryLock() ? null :
                scanAndLockForPut(key, hash, value);
            V oldValue;
            try {
                HashEntry&lt;K,V&gt;[] tab = table;
                int index = (tab.length - 1) &amp; hash;
                HashEntry&lt;K,V&gt; first = entryAt(tab, index);
                for (HashEntry&lt;K,V&gt; e = first;;) {
                    if (e != null) {
                        K k;
                        if ((k = e.key) == key ||
                            (e.hash == hash &amp;&amp; key.equals(k))) {
                            oldValue = e.value;
                            if (!onlyIfAbsent) {
                                e.value = value;
                                ++modCount;
                            }
                            break;
                        }
                        e = e.next;
                    }
                    else {
                        if (node != null)
                            node.setNext(first);
                        else
                            node = new HashEntry&lt;K,V&gt;(hash, key, value, first);
                        int c = count + 1;
                        if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)
                            rehash(node);
                        else
                            setEntryAt(tab, index, node);
                        ++modCount;
                        count = c;
                        oldValue = null;
                        break;
                    }
                }
            } finally {
                unlock();
            }
            return oldValue;
        }</code></pre>
<ol>
<li><p>是否需要扩容</p>
<p>在插入元素要判断<code>c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY</code>是否超过阈值，超过需要对数组扩容rehash。这扩容方式比HashMap更合理，HashMap是在插入元素后看是否达到容量扩容的，而如果后续没有新元素了，那这次扩容就变多余了，而ConcurrentHashMap是在插入元素前判断的。</p>
</li>
<li><p>如何扩容</p>
<p>在扩容的时候，首先会创建一个容量是原来两倍的数组，然后将原有数组里的元素进行再散列后插入到新数组里。为了高效，ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容。</p>
</li>
</ol>
<h3 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h3><pre><code class="java">    public int size() {
        // Try a few times to get accurate count. On failure due to
        // continuous async changes in table, resort to locking.
        final Segment&lt;K,V&gt;[] segments = this.segments;
        int size;
        boolean overflow; // true if size overflows 32 bits
        long sum;         // sum of modCounts
        long last = 0L;   // previous sum
        int retries = -1; // first iteration isn&#39;t retry
        try {
            for (;;) {
                if (retries++ == RETRIES_BEFORE_LOCK) {
                    for (int j = 0; j &lt; segments.length; ++j)
                        ensureSegment(j).lock(); // force creation
                }
                sum = 0L;
                size = 0;
                overflow = false;
                for (int j = 0; j &lt; segments.length; ++j) {
                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);
                    if (seg != null) {
                        sum += seg.modCount;
                        int c = seg.count;
                        if (c &lt; 0 || (size += c) &lt; 0)
                            overflow = true;
                    }
                }
                if (sum == last)
                    break;
                last = sum;
            }
        } finally {
            if (retries &gt; RETRIES_BEFORE_LOCK) {
                for (int j = 0; j &lt; segments.length; ++j)
                    segmentAt(segments, j).unlock();
            }
        }
        return overflow ? Integer.MAX_VALUE : size;
    }</code></pre>
<p>直接统计每个Segment下的count值，显然不安全。又或者把segment的put、remove、clean方法全部锁住，但是这种方式非常低效。</p>
<p>CountHashMap的做法是：</p>
<p>线程尝试2次不锁住Segment的方式来统计个Segment大小，如果统计过程中，容器count值发生改变，则再采用加锁的方式来统计所有Segment的大小。</p>
<p>那么，ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化了呢？答案是，跟之前一样使用modCount变量，在put、remove和clean方法里操作元素前都会讲变量modCount进行加1，那么在统计size前后比较modeCount是否发生变化，从而得知容器大小是否发生改变。</p>
<h1 id="JDK-1-8-之后的ConcurrentHashMap"><a href="#JDK-1-8-之后的ConcurrentHashMap" class="headerlink" title="JDK 1.8+之后的ConcurrentHashMap"></a>JDK 1.8+之后的ConcurrentHashMap</h1><p>在JDK1.8之后，ConcurrentHashMap发生了那些变化呢？</p>
<ul>
<li>总体结构上，它的内部存储变得与HashMap结构非常类似，同样是大的桶(数组)，然后内部也是一个个所谓的链表结构(bin)，同步的粒度更细致一些。</li>
<li>其内部仍然有Segment定义，但仅仅是位了保证序列化时的兼容性而已，不再有任何结构上的用处。</li>
<li>因为不再使用Segment，初始化操作大大简化，改为lazy-load形式，这样可以有效避免初始开销，解决了老版本很多人抱怨的这一点。</li>
<li>数据存储利用volatile来保证可见性。</li>
<li>使用CAS等操作，在特定场景下进行无锁并发操作。</li>
<li>使用Unsafe、LongAdder之类的底层手段，进行极端情况的优化。</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><pre><code class="java">    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        final int hash;
        final K key;
        volatile V val;
        volatile Node&lt;K,V&gt; next;

                //其他代码略
    }</code></pre>
<p>这里不在介绍get和构造函数了，直接来看put的源码是怎么实现的。</p>
<h2 id="put操作-1"><a href="#put操作-1" class="headerlink" title="put操作"></a>put操作</h2><pre><code class="java">    final V putVal(K key, V value, boolean onlyIfAbsent) {
        if (key == null || value == null) throw new NullPointerException();
        int hash = spread(key.hashCode());
        int binCount = 0;
        for (Node&lt;K,V&gt;[] tab = table;;) {
            Node&lt;K,V&gt; f; int n, i, fh;
            if (tab == null || (n = tab.length) == 0)
                tab = initTable();
            else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
              //(1)利用CAS进行无锁线程安全操作，如果修改元素数组链表的对应元素为空，曾使用cas设置数组的元素作为链表的头元素
                if (casTabAt(tab, i, null,
                             new Node&lt;K,V&gt;(hash, key, value, null)))
                    break;                   // no lock when adding to empty bin
            }
            else if ((fh = f.hash) == MOVED)
                tab = helpTransfer(tab, f);
            else {
                V oldVal = null;
                synchronized (f) { //(2)
                    if (tabAt(tab, i) == f) {//double check f
                        if (fh &gt;= 0) {
                            binCount = 1;
                            for (Node&lt;K,V&gt; e = f;; ++binCount) {
                                K ek;
                                if (e.hash == hash &amp;&amp;
                                    ((ek = e.key) == key ||
                                     (ek != null &amp;&amp; key.equals(ek)))) {
                                    oldVal = e.val;
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                }
                                Node&lt;K,V&gt; pred = e;
                                if ((e = e.next) == null) {
                                    pred.next = new Node&lt;K,V&gt;(hash, key,
                                                              value, null);
                                    break;
                                }
                            }
                        }
                        else if (f instanceof TreeBin) { //树化节点
                            Node&lt;K,V&gt; p;
                            binCount = 2;
                            if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                           value)) != null) {
                                oldVal = p.val;
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                    }
                }
                if (binCount != 0) {
                    if (binCount &gt;= TREEIFY_THRESHOLD)//(3)超过树化阈值
                        treeifyBin(tab, i);
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
        }
        addCount(1L, binCount);
        return null;
    }</code></pre>
<ul>
<li>(1) 利用CAS进行无锁线程安全操作，如果修改元素数组链表的对应元素为空，曾使用cas设置数组的元素作为链表的头元素</li>
<li>(2) 根据如果当前链表的头节点也就是table数组元素f非空，那么对f加锁并插入f对应的链表中。当然如果f是树化节点TreeBin，则以树化的方式插入。这里tabAt调用了两次一次是判断是不是空的时候，一次是重新定位判断是不是f本身，都是为了避免f已经被人修改的线程安全问题。</li>
<li>(3)如果当前链表长度Bin的大小大于树化的阈值TREEIFY_THRESHOLD(默认8)则进行树化。</li>
</ul>
<p>这里有几处优化，如：</p>
<ul>
<li>一处是当链表对应头节点组成的数组元素是空的时候需要调用<code>tab = initTable();</code>来初始化当前新增元素作为链表数组的一个元素。</li>
</ul>
<pre><code class="java">    private final Node&lt;K,V&gt;[] initTable() {
        Node&lt;K,V&gt;[] tab; int sc;
        while ((tab = table) == null || tab.length == 0) {
            if ((sc = sizeCtl) &lt; 0)
                Thread.yield(); // lost initialization race; just spin
            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
                try {
                    if ((tab = table) == null || tab.length == 0) {
                        int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;
                        @SuppressWarnings(&quot;unchecked&quot;)
                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];
                        table = tab = nt;
                        sc = n - (n &gt;&gt;&gt; 2);
                    }
                } finally {
                    sizeCtl = sc;
                }
                break;
            }
        }
        return tab;
    }
</code></pre>
<p>这里用了<code>compareAndSwapInt</code> 并且使用volatile变量SIZECTL控制数组容量这个共享变量的线程安全。</p>
<ul>
<li>第二处是在定位hash位置处的链表头节点元素时：</li>
</ul>
<pre><code class="java">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) {
    return (Node&lt;K,V&gt;)U.getObjectAcquire(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);
}</code></pre>
<p>通过使用Unsafe进行优化，避免间接调用的开销。</p>
<h2 id="size操作-1"><a href="#size操作-1" class="headerlink" title="size操作"></a>size操作</h2><pre><code class="java">    public int size() {
        long n = sumCount();
        return ((n &lt; 0L) ? 0 :
                (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :
                (int)n);
    }</code></pre>
<p>其中sumCount源码如下：</p>
<pre><code class="java">    /**
     * A padded cell for distributing counts.  Adapted from LongAdder
     * and Striped64.  See their internal docs for explanation.
     */
    @sun.misc.Contended static final class CounterCell {
        volatile long value;
        CounterCell(long x) { value = x; }
    }

    final long sumCount() {
        CounterCell[] as = counterCells; CounterCell a;
        long sum = baseCount;
        if (as != null) {
            for (int i = 0; i &lt; as.length; ++i) {
                if ((a = as[i]) != null)
                    sum += a.value;
            }
        }
        return sum;
    }</code></pre>
<p>这里的计数用到了CounterCell这个类，数据一致性是怎么保证的？</p>
<p>对于CounterCell的操作，是基于<code>java.util.concurrent.atomic.LongAdder</code>进行的，是一种利用空间换时间的更高效的方法了，利用了Striped64内部的复杂逻辑。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://my.oschina.net/pingpangkuangmo/blog/817973" target="_blank" rel="noopener">* jdk1.8的HashMap和ConcurrentHashMap </a></p>
<p><a href="https://www.wanaright.com/2018/09/30/java10-concurrenthashmap-no-segment-lock/" target="_blank" rel="noopener">Java8之后的ConcurrentHashMap, 舍弃分段锁</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1509556" target="_blank" rel="noopener">java8的ConcurrentHashMap为何放弃分段锁</a> 这篇文章讲到了jdk 1.7分段锁的劣势</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 tcals1@163.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>


<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>【并发容器和框架】一、CocurrentHashMap的实现原理与使用</p>
    <p><span class="copy-title">文章字数:</span><span class="post-count">3.6k</span></p>
    <p><span class="copy-title">本文作者:</span><a  title="Zhou Lei">Zhou Lei</a></p>
    <p><span class="copy-title">发布时间:</span>2019-10-27, 00:00:00</p>
    <p><span class="copy-title">最后更新:</span>2020-03-22, 18:10:51</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2019/10/27/java-concurrency-container-ConcurrentHashMap/" title="【并发容器和框架】一、CocurrentHashMap的实现原理与使用">2tongtong.cn/2019/10/27/java-concurrency-container-ConcurrentHashMap/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
    </p>
</div>





    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="//cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<input type="hidden" id="MathJax-js"
        value="//cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
</input>
    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2016-2020 ZhouLei</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" ></a>

    </div>
</div>
<div class="acParent"></div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.0.1" ></script>

<script src="/js/script.js?v=1.0.1" ></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#Jetty','#odl','#rpc','#HTTP','#HTTP2','#Markdown','#java','#LinkedList','#Collection','#集合','#work summary','#HashMap','#数据结构','#链表','#LinkedHashMap','#算法','#排序','#ArrayList','#随机梯度下降','#有监督','#线性回归','#并发框架','#Executor','#并发容器','#ConcurrentHashMap','#ForkJoin','#ThreadPool','#并发','#java红黑树','#操作系统','#进程','#线程','#Search','#Solr','#死锁','#线程的风险','#互斥锁','#管程','#生命周期','#线程协作','#wait','#阻塞队列','#信号量','#互斥','#可见性','#volatile','#ReadWriteLock','#synchronized','#Json Facet','#lock','#原子操作','#Lucene','#索引文件','#Lucene工具类','#DocValues','#idea','#Collector','#Lucene压缩算法',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().split('\n').length - 1, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0px;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 702px;
    }
    .nav.fullscreen {
        margin-left: -702px;
    }
    .nav-left {
        width: 180px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 692px;
        }
        .nav.fullscreen {
            margin-left: -692px;
        }
        .nav-left {
            width: 200px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 692px;
            margin-left: -692px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
        .nav .hide-list.fullscreen {
            left: 592px
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("https://i.loli.net/2019/07/22/5d3521411f3f169375.png");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
    .post .pjax article :not(pre) > code {
        color: #24292e;
        font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
        background-color: rgba(27,31,35,.05);
        border-radius: 3px;
        font-size: 85%;
        margin: 0;
        padding: .2em .4em;
    }
    
</style>







</html>
