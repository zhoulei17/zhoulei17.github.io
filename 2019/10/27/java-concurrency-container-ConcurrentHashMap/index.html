<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"2tongtong.cn","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"always","padding":25,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="为什么引入ConcurrentHashMap在并发编程中使用HashMap可能导致程序死循环。而使用线程安全的HashTable效率又非常低下，基于以上两个原因，便有了ConcurrentHash的出现。  线程不安全的HashMap 在多线程环境下，使用HashMap进行put操作会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的n">
<meta property="og:type" content="article">
<meta property="og:title" content="【并发容器和框架】一、CocurrentHashMap的实现原理与使用">
<meta property="og:url" content="2tongtong.cn/2019/10/27/java-concurrency-container-ConcurrentHashMap/index.html">
<meta property="og:site_name" content="Z.L&#39;s blog">
<meta property="og:description" content="为什么引入ConcurrentHashMap在并发编程中使用HashMap可能导致程序死循环。而使用线程安全的HashTable效率又非常低下，基于以上两个原因，便有了ConcurrentHash的出现。  线程不安全的HashMap 在多线程环境下，使用HashMap进行put操作会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的n">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="/img/in-post/image-20191030234301439.png">
<meta property="article:published_time" content="2019-10-26T16:00:00.000Z">
<meta property="article:modified_time" content="2020-03-22T10:10:51.949Z">
<meta property="article:author" content="Zhou Lei">
<meta property="article:tag" content="java">
<meta property="article:tag" content="并发容器">
<meta property="article:tag" content="ConcurrentHashMap">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="/img/in-post/image-20191030234301439.png">

<link rel="canonical" href="2tongtong.cn/2019/10/27/java-concurrency-container-ConcurrentHashMap/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>【并发容器和框架】一、CocurrentHashMap的实现原理与使用 | Z.L's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Z.L's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">53</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">58</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="2tongtong.cn/2019/10/27/java-concurrency-container-ConcurrentHashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.png">
      <meta itemprop="name" content="Zhou Lei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z.L's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【并发容器和框架】一、CocurrentHashMap的实现原理与使用
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-27 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-27T00:00:00+08:00">2019-10-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-22 18:10:51" itemprop="dateModified" datetime="2020-03-22T18:10:51+08:00">2020-03-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="为什么引入ConcurrentHashMap"><a href="#为什么引入ConcurrentHashMap" class="headerlink" title="为什么引入ConcurrentHashMap"></a>为什么引入ConcurrentHashMap</h1><p>在并发编程中使用HashMap可能导致程序死循环。而使用线程安全的HashTable效率又非常低下，基于以上两个原因，便有了ConcurrentHash的出现。</p>
<ul>
<li><p>线程不安全的HashMap</p>
<p>在多线程环境下，使用HashMap进行put操作会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。</p>
</li>
<li><p>效率低下的的HashTable</p>
<p>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。</p>
</li>
<li><p>ConcurrentHashMap的锁分段技术可有效提升并发率</p>
<p>HashTable在高并发下的效率低下的原因是因为所有访问HashTable的线程必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争。</p>
<p>存储数据时分成一段段存储，每一段分配一把锁，这样当一个线程访问其中一个段数据时，其他段数据依然可以被其他线程访问。</p>
</li>
</ul>
<p>  分段锁是JDK1.7及其之前的实现技术，JDK1.8并没有使用分段锁技术。</p>
<h1 id="JDK-1-7的ConcurrentHashMap"><a href="#JDK-1-7的ConcurrentHashMap" class="headerlink" title="JDK 1.7的ConcurrentHashMap"></a>JDK 1.7的ConcurrentHashMap</h1><p>ConcurrentHashMap的设计一直在演进中，JDK 1.7和JDK 1.8的ConcurrentHashMap实现存在巨大的差异，公司现在使用的是JDK 1.8，因此我们着重分析JDK 1.8，在此之前1.7也先介绍下。</p>
<h2 id="JDK-1-7的ConcurrentHashMap的结构"><a href="#JDK-1-7的ConcurrentHashMap的结构" class="headerlink" title="JDK 1.7的ConcurrentHashMap的结构"></a>JDK 1.7的ConcurrentHashMap的结构</h2><p>主要结构由：</p>
<ul>
<li>分离锁 <strong>Segment</strong>、Segment内部集成一个<strong>HashEntry</strong>的数组。<ul>
<li>Segment是一种可重入锁，一个ConcurrentHashMap包含一个Segment数组，一个Segment包含一个HashEntry数组。Segment的结构与HashMap类似是一种数组和链表的结构。</li>
<li>每个HashEntry是一个链表结构的元素。</li>
</ul>
</li>
<li>HashEntry内部使用volatile的value字段来保证可见性，也利用了不可变对象的机制以改进利用Unsafe提供的底层能力，比如volatile access，直接完成部分操作，以优化性能，毕竟Unsafe中的很多操作是JVM intrinsic优化过的。</li>
</ul>
<p><img data-src="/img/in-post/image-20191030234301439.png" alt=""></p>
<h2 id="JDK-1-7-ConcurrentHashMap初始化"><a href="#JDK-1-7-ConcurrentHashMap初始化" class="headerlink" title="JDK 1.7 ConcurrentHashMap初始化"></a>JDK 1.7 ConcurrentHashMap初始化</h2><h3 id="1-初始化segment数组"><a href="#1-初始化segment数组" class="headerlink" title="1. 初始化segment数组"></a>1. 初始化segment数组</h3><p>先看源码：</p>
<pre><code class="java">    public ConcurrentHashMap(int initialCapacity,
                             float loadFactor, int concurrencyLevel) {
        if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)
            throw new IllegalArgumentException();
        if (concurrencyLevel &gt; MAX_SEGMENTS)
            concurrencyLevel = MAX_SEGMENTS;
        // Find power-of-two sizes best matching arguments
        int sshift = 0;
        int ssize = 1;
        while (ssize &lt; concurrencyLevel) {
            ++sshift;
            ssize &lt;&lt;= 1;
        }
        this.segmentShift = 32 - sshift;
        this.segmentMask = ssize - 1;
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        int c = initialCapacity / ssize;
        if (c * ssize &lt; initialCapacity)
            ++c;
        int cap = MIN_SEGMENT_TABLE_CAPACITY;
        while (cap &lt; c)
            cap &lt;&lt;= 1;
        // create segments and segments[0]
        Segment&lt;K,V&gt; s0 =
            new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),
                             (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);
        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];
        UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
        this.segments = ss;
    }</code></pre>
<p>Segments的长度ssize由concurrencyLevel计算得到。为了能通过按位与的散列算法来定位segment数组的索引，必须保证segments数组的长度是2的N次方，所以必须计算出一个大于等于concurrencyLevel的最小的2的N次方值作为segments的长度。假如concurrencyLevel等于14、15或16，ssize都会等于16，即容器里锁的个数也是16。</p>
<h3 id="2-初始化segmentShift和segmentMask"><a href="#2-初始化segmentShift和segmentMask" class="headerlink" title="2. 初始化segmentShift和segmentMask"></a>2. 初始化segmentShift和segmentMask</h3><p>这两个全局变量是用来定位segment的散列算法里使用的，sshift等于ssize从1向左移位的次数。concurrencyLevel默认等于16，所以sshift等于4。</p>
<ul>
<li>segmentShift用与定位参与散列运算的位数，segmentShift等于32减sshift，所以等于28（之所以是32是因为hash()的最大输出是32）。</li>
<li>segmentMask是散列运算的掩码，等于ssize减1，即15，掩码的二进制各位都是1.因为ssize的最大值都是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。</li>
</ul>
<h3 id="3-初始化每个segment"><a href="#3-初始化每个segment" class="headerlink" title="3. 初始化每个segment"></a>3. 初始化每个segment</h3><p>cap是每个segment里的HashEntry数组的长度，它等于initialCapacity/ssize的倍数c。</p>
<p>segment的容量threshold=(int)cap*loadFactor，默认情况下initialCapacity等于16，loadfactor等于0.75。</p>
<p><strong>可以看到这里的segment元素就类似于原先HashMap的结构，segment的每个元素内都存有类似HashMap的数组链表结构</strong>(如上图)。</p>
<h2 id="如何定位Segment"><a href="#如何定位Segment" class="headerlink" title="如何定位Segment"></a>如何定位Segment</h2><p>ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素时，必须先通过散列算法来定位到Segment。</p>
<pre><code class="java">   private static int hash(int h) {
        // Spread bits to regularize both segment and index locations,
        // using variant of single-word Wang/Jenkins hash.
        h += (h &lt;&lt;  15) ^ 0xffffcd7d;
        h ^= (h &gt;&gt;&gt; 10);
        h += (h &lt;&lt;   3);
        h ^= (h &gt;&gt;&gt;  6);
        h += (h &lt;&lt;   2) + (h &lt;&lt; 14);
        return h ^ (h &gt;&gt;&gt; 16);
    }</code></pre>
<p>首先会使用Wang/Jekins hash的变种算法对元素的hashCode进行一次再散列，之所进行再散列是为了避免散列冲突，使元素均匀地分布在不同的Segment上，从而提高容器的存取效率。ConcurrentHashMap通过以上hash算法对hashCode计算出的hash值以后再通过以下散列算法定位segment。</p>
<pre><code class="java">    private Segment&lt;K,V&gt; segmentForHash(int h) {
        long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;
        return (Segment&lt;K,V&gt;) UNSAFE.getObjectVolatile(segments, u);
    }</code></pre>
<p>默认情况下segmentShift为28，segmentMask为15，再散列后的数最大是32位二进制数据。</p>
<p>向右无符号移动28位，相当于让高4位参与到散列运算中，<code>(h &gt;&gt;&gt; segmentShift) &amp; segmentMask</code>的运算结构是4、15、7和8，可以看到散列值没有发生冲突。</p>
<h2 id="JDK-1-7-ConcurrentHashMap的操作"><a href="#JDK-1-7-ConcurrentHashMap的操作" class="headerlink" title="JDK 1.7 ConcurrentHashMap的操作"></a>JDK 1.7 ConcurrentHashMap的操作</h2><p>主要介绍get 、put、size操作。</p>
<h3 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h3><pre><code class="java">    public V get(Object key) {
        Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead
        HashEntry&lt;K,V&gt;[] tab;
        int h = hash(key.hashCode());
        long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;
        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;
            (tab = s.table) != null) {
            for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile
                     (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);
                 e != null; e = e.next) {
                K k;
                if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))
                    return e.value;
            }
        }
        return null;
    }</code></pre>
<p>get的高效之处在于，整个get过程不加锁，主要通过UNSAFE的getObjectVolatile方法获取值，即直接获取volatile的值。</p>
<p><code>UNSAFE.getObjectVolatile(tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE)</code>获取HashEntry数组节点表示的链表元素时定位的<code>(tab.length - 1) &amp; h)</code>直接使用的是再散列后的值，而定位segment是通过再散列的值的高位来定位的。</p>
<p>其目的是避免两次散列后的值一样，虽然元素Segment里散列开了，但却没有在HashEntry里散列开来。</p>
<h3 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h3><p>在操作共享变量时必须加锁。put方法首先定位到Segment，然后在Segment里进行插入操作。</p>
<pre><code class="java">    public V put(K key, V value) {
        Segment&lt;K,V&gt; s;
        if (value == null)
            throw new NullPointerException();
        int hash = hash(key.hashCode());
        int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;
        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck
             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment
            s = ensureSegment(j);
        return s.put(key, hash, value, false);
    }</code></pre>
<p>Segment的插入操作：</p>
<pre><code class="java">        final V put(K key, int hash, V value, boolean onlyIfAbsent) {
            HashEntry&lt;K,V&gt; node = tryLock() ? null :
                scanAndLockForPut(key, hash, value);
            V oldValue;
            try {
                HashEntry&lt;K,V&gt;[] tab = table;
                int index = (tab.length - 1) &amp; hash;
                HashEntry&lt;K,V&gt; first = entryAt(tab, index);
                for (HashEntry&lt;K,V&gt; e = first;;) {
                    if (e != null) {
                        K k;
                        if ((k = e.key) == key ||
                            (e.hash == hash &amp;&amp; key.equals(k))) {
                            oldValue = e.value;
                            if (!onlyIfAbsent) {
                                e.value = value;
                                ++modCount;
                            }
                            break;
                        }
                        e = e.next;
                    }
                    else {
                        if (node != null)
                            node.setNext(first);
                        else
                            node = new HashEntry&lt;K,V&gt;(hash, key, value, first);
                        int c = count + 1;
                        if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)
                            rehash(node);
                        else
                            setEntryAt(tab, index, node);
                        ++modCount;
                        count = c;
                        oldValue = null;
                        break;
                    }
                }
            } finally {
                unlock();
            }
            return oldValue;
        }</code></pre>
<ol>
<li><p>是否需要扩容</p>
<p>在插入元素要判断<code>c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY</code>是否超过阈值，超过需要对数组扩容rehash。这扩容方式比HashMap更合理，HashMap是在插入元素后看是否达到容量扩容的，而如果后续没有新元素了，那这次扩容就变多余了，而ConcurrentHashMap是在插入元素前判断的。</p>
</li>
<li><p>如何扩容</p>
<p>在扩容的时候，首先会创建一个容量是原来两倍的数组，然后将原有数组里的元素进行再散列后插入到新数组里。为了高效，ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容。</p>
</li>
</ol>
<h3 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h3><pre><code class="java">    public int size() {
        // Try a few times to get accurate count. On failure due to
        // continuous async changes in table, resort to locking.
        final Segment&lt;K,V&gt;[] segments = this.segments;
        int size;
        boolean overflow; // true if size overflows 32 bits
        long sum;         // sum of modCounts
        long last = 0L;   // previous sum
        int retries = -1; // first iteration isn&#39;t retry
        try {
            for (;;) {
                if (retries++ == RETRIES_BEFORE_LOCK) {
                    for (int j = 0; j &lt; segments.length; ++j)
                        ensureSegment(j).lock(); // force creation
                }
                sum = 0L;
                size = 0;
                overflow = false;
                for (int j = 0; j &lt; segments.length; ++j) {
                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);
                    if (seg != null) {
                        sum += seg.modCount;
                        int c = seg.count;
                        if (c &lt; 0 || (size += c) &lt; 0)
                            overflow = true;
                    }
                }
                if (sum == last)
                    break;
                last = sum;
            }
        } finally {
            if (retries &gt; RETRIES_BEFORE_LOCK) {
                for (int j = 0; j &lt; segments.length; ++j)
                    segmentAt(segments, j).unlock();
            }
        }
        return overflow ? Integer.MAX_VALUE : size;
    }</code></pre>
<p>直接统计每个Segment下的count值，显然不安全。又或者把segment的put、remove、clean方法全部锁住，但是这种方式非常低效。</p>
<p>CountHashMap的做法是：</p>
<p>线程尝试2次不锁住Segment的方式来统计个Segment大小，如果统计过程中，容器count值发生改变，则再采用加锁的方式来统计所有Segment的大小。</p>
<p>那么，ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化了呢？答案是，跟之前一样使用modCount变量，在put、remove和clean方法里操作元素前都会讲变量modCount进行加1，那么在统计size前后比较modeCount是否发生变化，从而得知容器大小是否发生改变。</p>
<h1 id="JDK-1-8-之后的ConcurrentHashMap"><a href="#JDK-1-8-之后的ConcurrentHashMap" class="headerlink" title="JDK 1.8+之后的ConcurrentHashMap"></a>JDK 1.8+之后的ConcurrentHashMap</h1><p>在JDK1.8之后，ConcurrentHashMap发生了那些变化呢？</p>
<ul>
<li>总体结构上，它的内部存储变得与HashMap结构非常类似，同样是大的桶(数组)，然后内部也是一个个所谓的链表结构(bin)，同步的粒度更细致一些。</li>
<li>其内部仍然有Segment定义，但仅仅是位了保证序列化时的兼容性而已，不再有任何结构上的用处。</li>
<li>因为不再使用Segment，初始化操作大大简化，改为lazy-load形式，这样可以有效避免初始开销，解决了老版本很多人抱怨的这一点。</li>
<li>数据存储利用volatile来保证可见性。</li>
<li>使用CAS等操作，在特定场景下进行无锁并发操作。</li>
<li>使用Unsafe、LongAdder之类的底层手段，进行极端情况的优化。</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><pre><code class="java">    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        final int hash;
        final K key;
        volatile V val;
        volatile Node&lt;K,V&gt; next;

                //其他代码略
    }</code></pre>
<p>这里不在介绍get和构造函数了，直接来看put的源码是怎么实现的。</p>
<h2 id="put操作-1"><a href="#put操作-1" class="headerlink" title="put操作"></a>put操作</h2><pre><code class="java">    final V putVal(K key, V value, boolean onlyIfAbsent) {
        if (key == null || value == null) throw new NullPointerException();
        int hash = spread(key.hashCode());
        int binCount = 0;
        for (Node&lt;K,V&gt;[] tab = table;;) {
            Node&lt;K,V&gt; f; int n, i, fh;
            if (tab == null || (n = tab.length) == 0)
                tab = initTable();
            else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
              //(1)利用CAS进行无锁线程安全操作，如果修改元素数组链表的对应元素为空，曾使用cas设置数组的元素作为链表的头元素
                if (casTabAt(tab, i, null,
                             new Node&lt;K,V&gt;(hash, key, value, null)))
                    break;                   // no lock when adding to empty bin
            }
            else if ((fh = f.hash) == MOVED)
                tab = helpTransfer(tab, f);
            else {
                V oldVal = null;
                synchronized (f) { //(2)
                    if (tabAt(tab, i) == f) {//double check f
                        if (fh &gt;= 0) {
                            binCount = 1;
                            for (Node&lt;K,V&gt; e = f;; ++binCount) {
                                K ek;
                                if (e.hash == hash &amp;&amp;
                                    ((ek = e.key) == key ||
                                     (ek != null &amp;&amp; key.equals(ek)))) {
                                    oldVal = e.val;
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                }
                                Node&lt;K,V&gt; pred = e;
                                if ((e = e.next) == null) {
                                    pred.next = new Node&lt;K,V&gt;(hash, key,
                                                              value, null);
                                    break;
                                }
                            }
                        }
                        else if (f instanceof TreeBin) { //树化节点
                            Node&lt;K,V&gt; p;
                            binCount = 2;
                            if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                           value)) != null) {
                                oldVal = p.val;
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                    }
                }
                if (binCount != 0) {
                    if (binCount &gt;= TREEIFY_THRESHOLD)//(3)超过树化阈值
                        treeifyBin(tab, i);
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
        }
        addCount(1L, binCount);
        return null;
    }</code></pre>
<ul>
<li>(1) 利用CAS进行无锁线程安全操作，如果修改元素数组链表的对应元素为空，曾使用cas设置数组的元素作为链表的头元素</li>
<li>(2) 根据如果当前链表的头节点也就是table数组元素f非空，那么对f加锁并插入f对应的链表中。当然如果f是树化节点TreeBin，则以树化的方式插入。这里tabAt调用了两次一次是判断是不是空的时候，一次是重新定位判断是不是f本身，都是为了避免f已经被人修改的线程安全问题。</li>
<li>(3)如果当前链表长度Bin的大小大于树化的阈值TREEIFY_THRESHOLD(默认8)则进行树化。</li>
</ul>
<p>这里有几处优化，如：</p>
<ul>
<li>一处是当链表对应头节点组成的数组元素是空的时候需要调用<code>tab = initTable();</code>来初始化当前新增元素作为链表数组的一个元素。</li>
</ul>
<pre><code class="java">    private final Node&lt;K,V&gt;[] initTable() {
        Node&lt;K,V&gt;[] tab; int sc;
        while ((tab = table) == null || tab.length == 0) {
            if ((sc = sizeCtl) &lt; 0)
                Thread.yield(); // lost initialization race; just spin
            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
                try {
                    if ((tab = table) == null || tab.length == 0) {
                        int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;
                        @SuppressWarnings(&quot;unchecked&quot;)
                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];
                        table = tab = nt;
                        sc = n - (n &gt;&gt;&gt; 2);
                    }
                } finally {
                    sizeCtl = sc;
                }
                break;
            }
        }
        return tab;
    }
</code></pre>
<p>这里用了<code>compareAndSwapInt</code> 并且使用volatile变量SIZECTL控制数组容量这个共享变量的线程安全。</p>
<ul>
<li>第二处是在定位hash位置处的链表头节点元素时：</li>
</ul>
<pre><code class="java">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) {
    return (Node&lt;K,V&gt;)U.getObjectAcquire(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);
}</code></pre>
<p>通过使用Unsafe进行优化，避免间接调用的开销。</p>
<h2 id="size操作-1"><a href="#size操作-1" class="headerlink" title="size操作"></a>size操作</h2><pre><code class="java">    public int size() {
        long n = sumCount();
        return ((n &lt; 0L) ? 0 :
                (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :
                (int)n);
    }</code></pre>
<p>其中sumCount源码如下：</p>
<pre><code class="java">    /**
     * A padded cell for distributing counts.  Adapted from LongAdder
     * and Striped64.  See their internal docs for explanation.
     */
    @sun.misc.Contended static final class CounterCell {
        volatile long value;
        CounterCell(long x) { value = x; }
    }

    final long sumCount() {
        CounterCell[] as = counterCells; CounterCell a;
        long sum = baseCount;
        if (as != null) {
            for (int i = 0; i &lt; as.length; ++i) {
                if ((a = as[i]) != null)
                    sum += a.value;
            }
        }
        return sum;
    }</code></pre>
<p>这里的计数用到了CounterCell这个类，数据一致性是怎么保证的？</p>
<p>对于CounterCell的操作，是基于<code>java.util.concurrent.atomic.LongAdder</code>进行的，是一种利用空间换时间的更高效的方法了，利用了Striped64内部的复杂逻辑。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://my.oschina.net/pingpangkuangmo/blog/817973" target="_blank" rel="noopener">* jdk1.8的HashMap和ConcurrentHashMap </a></p>
<p><a href="https://www.wanaright.com/2018/09/30/java10-concurrenthashmap-no-segment-lock/" target="_blank" rel="noopener">Java8之后的ConcurrentHashMap, 舍弃分段锁</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1509556" target="_blank" rel="noopener">java8的ConcurrentHashMap为何放弃分段锁</a> 这篇文章讲到了jdk 1.7分段锁的劣势</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>如果乐意，请喝杯茶吧.</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/webchatpay.jpeg" alt="Zhou Lei 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpeg" alt="Zhou Lei 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/" rel="tag"># 并发容器</a>
              <a href="/tags/ConcurrentHashMap/" rel="tag"># ConcurrentHashMap</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/10/22/Algorithms_DS_DS_Link/" rel="prev" title="【数据结构与算法】-【数据结构篇】链表">
      <i class="fa fa-chevron-left"></i> 【数据结构与算法】-【数据结构篇】链表
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/10/30/Algorithms_AL_Sort/" rel="next" title="【数据结构与算法】-【算法】排序">
      【数据结构与算法】-【算法】排序 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么引入ConcurrentHashMap"><span class="nav-number">1.</span> <span class="nav-text">为什么引入ConcurrentHashMap</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK-1-7的ConcurrentHashMap"><span class="nav-number">2.</span> <span class="nav-text">JDK 1.7的ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK-1-7的ConcurrentHashMap的结构"><span class="nav-number">2.1.</span> <span class="nav-text">JDK 1.7的ConcurrentHashMap的结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK-1-7-ConcurrentHashMap初始化"><span class="nav-number">2.2.</span> <span class="nav-text">JDK 1.7 ConcurrentHashMap初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-初始化segment数组"><span class="nav-number">2.2.1.</span> <span class="nav-text">1. 初始化segment数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-初始化segmentShift和segmentMask"><span class="nav-number">2.2.2.</span> <span class="nav-text">2. 初始化segmentShift和segmentMask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-初始化每个segment"><span class="nav-number">2.2.3.</span> <span class="nav-text">3. 初始化每个segment</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何定位Segment"><span class="nav-number">2.3.</span> <span class="nav-text">如何定位Segment</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK-1-7-ConcurrentHashMap的操作"><span class="nav-number">2.4.</span> <span class="nav-text">JDK 1.7 ConcurrentHashMap的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#get操作"><span class="nav-number">2.4.1.</span> <span class="nav-text">get操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#put操作"><span class="nav-number">2.4.2.</span> <span class="nav-text">put操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#size操作"><span class="nav-number">2.4.3.</span> <span class="nav-text">size操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK-1-8-之后的ConcurrentHashMap"><span class="nav-number">3.</span> <span class="nav-text">JDK 1.8+之后的ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构"><span class="nav-number">3.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#put操作-1"><span class="nav-number">3.2.</span> <span class="nav-text">put操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#size操作-1"><span class="nav-number">3.3.</span> <span class="nav-text">size操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">4.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhou Lei"
      src="/images/avatar2.png">
  <p class="site-author-name" itemprop="name">Zhou Lei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">58</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhoulei17" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhoulei17" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:tcals1@163.com" title="E-Mail → mailto:tcals1@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="/zhoulei.site" title="zhoulei.site">site</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhou Lei</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">221k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:21</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
